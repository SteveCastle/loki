{{ define "detail" }}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Job {{.Job.ID}}</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      .detail-container {
        max-width: 1400px;
        margin: 0 auto;
        padding: var(--space-5);
      }

      header {
        background: var(--bg-card);
        border: 1px solid var(--border-subtle);
        padding: var(--space-5);
        border-radius: var(--radius-xl);
        margin-bottom: var(--space-5);
        box-shadow: var(--shadow-sm);
      }

      .breadcrumbs {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        margin-bottom: var(--space-4);
        min-height: 18px;
      }

      .breadcrumb-path {
        text-decoration: none;
        color: var(--accent-primary);
        opacity: 0.8;
        transition: opacity var(--transition-fast);
        font-size: var(--text-sm);
      }

      .breadcrumb-path:hover {
        opacity: 1;
      }

      .breadcrumb-separator {
        color: var(--text-muted);
        display: inline-block;
      }

      .breadcrumb-leaf {
        color: var(--text-primary);
        font-weight: 600;
        font-size: var(--text-sm);
      }

      .meta-info {
        margin-top: var(--space-3);
        font-size: var(--text-sm);
        color: var(--text-secondary);
      }

      .meta-info > div {
        margin-bottom: var(--space-2);
      }

      .meta-info strong {
        color: var(--text-primary);
      }

      .terminal {
        background: var(--bg-base);
        border: 1px solid var(--border-subtle);
        border-radius: var(--radius-xl);
        height: 60vh;
        overflow-y: auto;
        margin-bottom: var(--space-5);
        position: relative;
      }

      .terminal-viewport {
        padding: var(--space-4);
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
      }

      .terminal-line {
        white-space: pre;
        overflow: hidden;
        text-overflow: ellipsis;
        height: 24px;
        line-height: 24px;
        color: var(--text-secondary);
        font-family: var(--font-mono);
        font-size: var(--text-sm);
        padding: 0 var(--space-4);
      }

      .terminal-line a {
        color: var(--accent-cyan);
        text-decoration: none;
        cursor: pointer;
        transition: opacity var(--transition-fast);
      }

      .terminal-line a:hover {
        opacity: 0.8;
        text-decoration: underline;
      }

      .terminal-line a.local-path {
        color: var(--accent-primary);
      }

      .terminal-line a.local-path:hover {
        color: var(--accent-cyan);
      }

      header button {
        font-size: var(--text-sm);
        padding: var(--space-2) var(--space-4);
        background: transparent;
        border: 1px solid var(--accent-primary);
        color: var(--accent-primary);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-fast);
        margin-left: var(--space-3);
      }

      header button:hover {
        background: var(--accent-primary);
        color: var(--bg-base);
      }

      /* Status styling */
      .status-section {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        margin-bottom: var(--space-3);
      }

      .job-status {
        width: 12px;
        height: 12px;
        border-radius: var(--radius-full);
        display: inline-block;
        margin-left: var(--space-2);
        border: none;
        animation: none;
      }

      .job-status.pending {
        background-color: var(--status-pending);
      }

      .job-status.in-progress {
        background-color: transparent;
        border: 2px solid var(--accent-cyan);
        border-top-color: transparent;
        animation: spin 1s linear infinite;
      }

      .job-status.completed {
        background-color: var(--status-success);
      }

      .job-status.cancelled {
        background-color: var(--status-warning);
      }

      .job-status.error {
        background-color: var(--status-error);
      }

      .status-text {
        font-weight: 600;
        padding: var(--space-1) var(--space-3);
        border-radius: var(--radius-md);
        font-size: var(--text-sm);
      }

      .status-text.pending {
        color: var(--status-pending);
        background-color: var(--status-pending-dim);
      }

      .status-text.in-progress {
        color: var(--accent-cyan);
        background-color: var(--accent-cyan-dim);
      }

      .status-text.completed {
        color: var(--status-success);
        background-color: var(--status-success-dim);
      }

      .status-text.cancelled {
        color: var(--status-warning);
        background-color: var(--status-warning-dim);
      }

      .status-text.error {
        color: var(--status-error);
        background-color: var(--status-error-dim);
      }

      /* Command styling */
      .command-section {
        margin-bottom: var(--space-3);
        display: flex;
        flex-wrap: wrap;
        align-items: baseline;
        gap: var(--space-2);
      }

      .command-name {
        color: var(--accent-primary);
        font-family: var(--font-mono);
        font-weight: 600;
      }

      .command-args {
        color: var(--accent-purple);
        font-family: var(--font-mono);
        font-size: var(--text-sm);
      }

      .command-input {
        color: var(--status-pending);
        font-family: var(--font-mono);
        font-weight: 500;
        background-color: var(--status-pending-dim);
        padding: var(--space-1) var(--space-2);
        border-radius: var(--radius-sm);
        border: 1px solid rgba(245, 158, 11, 0.3);
        font-size: var(--text-sm);
      }

      @media screen and (max-width: 800px) {
        .detail-container {
          padding: var(--space-3);
        }

        header {
          padding: var(--space-4);
        }

        .command-section {
          gap: var(--space-2);
        }

        .terminal {
          height: 50vh;
        }

        header button {
          margin-left: var(--space-2);
          margin-top: var(--space-2);
        }
      }
    </style>
  </head>
  <body>
    <div class="detail-container">
      {{ template "topnav" . }} {{ template "detailHeader" .Job }}

      <div class="terminal" id="terminal-scroller">
        <div id="terminal-phantom"></div>
        <div id="terminal-viewport" class="terminal-viewport"></div>
      </div>
    </div>

    <script>
      // Escape HTML special characters
      function escapeHtml(text) {
        return text
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;');
      }

      // Linkify URLs and local paths in terminal output
      function linkifyText(text) {
        if (!text) return '';

        // Combined pattern to match URLs and Windows paths in a single pass
        // This prevents double-matching and maintains proper order
        // Windows paths can contain spaces and common special characters
        // Allowed: alphanumerics, spaces, . _ - \ ( ) [ ] { } @ # $ % & ! ~ ` ' +
        const combinedPattern =
          /(https?:\/\/[^\s<>"']+)|([A-Za-z]:\\[\w\s.\-\\()\[\]{}@#$%&!~`'+]+)/g;

        let lastIndex = 0;
        let result = '';
        let match;

        while ((match = combinedPattern.exec(text)) !== null) {
          // Add escaped text before this match
          const before = text.slice(lastIndex, match.index);
          result += escapeHtml(before);

          const url = match[1];
          let winPath = match[2];

          if (url) {
            // It's a URL - open in new tab
            result += `<a href="${escapeHtml(
              url
            )}" target="_blank" rel="noopener noreferrer">${escapeHtml(
              url
            )}</a>`;
          } else if (winPath) {
            // Trim trailing whitespace from the path (spaces are valid in paths but not at the end)
            winPath = winPath.trimEnd();
            // It's a Windows path - open with OS default app
            const escapedPath = escapeHtml(winPath);
            result += `<a href="#" class="local-path" data-path="${escapedPath}" onclick="openLocalPath(event, this)">${escapedPath}</a>`;
          }

          lastIndex = match.index + match[0].length;
        }

        // Add remaining text after last match
        result += escapeHtml(text.slice(lastIndex));

        return result;
      }

      // Open local path using OS default application
      function openLocalPath(event, element) {
        event.preventDefault();
        const path = element.getAttribute('data-path');
        if (!path) return;

        fetch('/open', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: path }),
        })
          .then((response) => {
            if (!response.ok) {
              console.error('Failed to open path:', path);
            }
          })
          .catch((err) => console.error('Error opening path:', err));
      }

      class VirtualTerminal {
        constructor(containerId, phantomId, viewportId, lines, rowHeight = 24) {
          this.scroller = document.getElementById(containerId);
          this.phantom = document.getElementById(phantomId);
          this.viewport = document.getElementById(viewportId);
          this.lines = lines || [];
          this.rowHeight = rowHeight;
          this.visibleCount = 0;
          this.buffer = 20; // Extra lines above/below
          this.autoScroll = true;

          // Padding inside the scroller affects the math
          // We need to account for it in the viewport transform
          // In CSS .terminal-viewport has top: 0, which is relative to the scroller content box
          // but we want the transform to push it down relative to the start of the phantom content.

          this.scroller.addEventListener('scroll', () => this.onScroll());

          // Initial setup
          this.updateHeight();
          this.calcVisible();
          this.render();

          // Scroll to bottom initially
          if (this.lines.length > 0) {
            this.scrollToBottom();
          }

          // Handle resize
          window.addEventListener('resize', () => {
            this.calcVisible();
            this.render();
          });
        }

        scrollToBottom() {
          this.scroller.scrollTop = this.scroller.scrollHeight;
          this.autoScroll = true;
        }

        calcVisible() {
          // Calculate how many items fit in the viewport
          this.visibleCount = Math.ceil(
            this.scroller.clientHeight / this.rowHeight
          );
        }

        updateHeight() {
          // Set the height of the phantom element to force the scrollbar
          // Add some padding for the bottom to look nice
          this.phantom.style.height = `${this.lines.length * this.rowHeight}px`;
        }

        onScroll() {
          const scrollTop = this.scroller.scrollTop;
          const clientHeight = this.scroller.clientHeight;
          const scrollHeight = this.scroller.scrollHeight;

          // Determine if we should auto-scroll (are we near the bottom?)
          // Tolerance of 20px
          this.autoScroll = scrollHeight - scrollTop - clientHeight < 50;

          this.render();
        }

        appendLine(line) {
          this.lines.push(line);
          this.updateHeight();

          if (this.autoScroll) {
            this.scrollToBottom();
            this.render();
          } else {
            // Even if not scrolling, if we are near the updated area we might need render?
            // Usually not necessary unless we are deleting/inserting in middle.
            // But if the user scrolled up, and we append, the phantom height grows,
            // but scrollTop stays same, so view stays stable.
          }
        }

        render() {
          const scrollTop = this.scroller.scrollTop;
          const startIndex = Math.floor(scrollTop / this.rowHeight);

          const renderStart = Math.max(0, startIndex - this.buffer);
          const renderEnd = Math.min(
            this.lines.length,
            startIndex + this.visibleCount + this.buffer
          );

          const offsetY = renderStart * this.rowHeight;

          // Optimization: avoid DOM thrashing if range hasn't changed significantly?
          // For simplicity, just rebuild. HTML string building is fast.

          let html = '';
          for (let i = renderStart; i < renderEnd; i++) {
            html += `<div class="terminal-line">${linkifyText(
              this.lines[i]
            )}</div>`;
          }

          this.viewport.innerHTML = html;
          // The padding of the container (var(--space-4) = usually 16px) is handled by the absolute positioning
          // of the viewport?
          // Actually, we replaced .terminal-content with .terminal-viewport.
          // .terminal-viewport has absolute positioning.
          // We need to offset it by the scrolled amount + padding if needed.
          // The phantom creates the scroll height. The viewport sits at top:0.
          // We translate the viewport down to where the content should be.
          // But we must add the container padding if we want it to align with the top padding.
          // Let's assume padding is handled by the viewport's internal padding or the container's padding?
          // If container has padding, scrollHeight includes it?
          // Let's assume .terminal has padding? No, it has no padding in CSS now.
          // .terminal-viewport has padding.

          // To position correctly within the scrollable area (which is defined by phantom),
          // we just translate Y.
          this.viewport.style.transform = `translateY(${offsetY}px)`;
        }
      }
    </script>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        // Initialize virtual terminal with server-side data
        const initialLines = {{ json .Job.Stdout }} || [];
        // rowHeight 24px matches CSS (24px height)
        const term = new VirtualTerminal('terminal-scroller', 'terminal-phantom', 'terminal-viewport', initialLines, 24);

        const STREAM_URL = '/stream';
        const EVENT_STDOUT = 'stdout-{{.Job.ID}}';
        const EVENT_UPDATE = 'update';

        const sseState = {
          es: null,
          reconnectTimer: null,
          heartbeatTimer: null,
          connectingTimer: null,
          backoffMs: 1000,
          maxBackoffMs: 30000,
          isConnecting: false,
          isExplicitlyClosed: false,
          lastActivityTs: Date.now(),
          lifecycleSetup: false,
        };

        function withJitter(ms) {
          const jitter = Math.floor(ms * 0.2 * Math.random());
          return ms + jitter;
        }

        function resetBackoff() {
          sseState.backoffMs = 1000;
        }

        function onActivity() {
          sseState.lastActivityTs = Date.now();
          resetBackoff();
        }

        function stopHeartbeat() {
          if (sseState.heartbeatTimer) {
            clearInterval(sseState.heartbeatTimer);
            sseState.heartbeatTimer = null;
          }
        }

        function startHeartbeat() {
          stopHeartbeat();
          sseState.heartbeatTimer = setInterval(() => {
            const inactiveMs = Date.now() - sseState.lastActivityTs;
            if (inactiveMs > 45000) {
              console.warn('SSE idle too long; recreating connection');
              recreateConnection();
            }
          }, 15000);
        }

        function clearConnectingTimer() {
          if (sseState.connectingTimer) {
            clearTimeout(sseState.connectingTimer);
            sseState.connectingTimer = null;
          }
        }

        function scheduleReconnect(reason) {
          if (sseState.isExplicitlyClosed) return;
          if (sseState.reconnectTimer) return;
          const delay = withJitter(sseState.backoffMs);
          console.log(`SSE reconnect in ${delay}ms (${reason || ''})`);
          sseState.reconnectTimer = setTimeout(() => {
            sseState.reconnectTimer = null;
            connect();
          }, delay);
          sseState.backoffMs = Math.min(
            sseState.maxBackoffMs,
            sseState.backoffMs * 2
          );
        }

        function cleanupES(markExplicit) {
          if (markExplicit) sseState.isExplicitlyClosed = true;
          stopHeartbeat();
          clearConnectingTimer();
          if (sseState.es) {
            try {
              sseState.es.close();
            } catch (e) {}
          }
          sseState.es = null;
          sseState.isConnecting = false;
        }

        function recreateConnection() {
          cleanupES(false);
          connect();
        }

        function connect() {
          if (sseState.isConnecting) return;
          if (sseState.es && sseState.es.readyState !== EventSource.CLOSED)
            return;
          if (!navigator.onLine) {
            scheduleReconnect('offline');
            return;
          }
          if (document.visibilityState === 'hidden') {
            scheduleReconnect('hidden');
            return;
          }

          sseState.isConnecting = true;
          try {
            console.log('SSE connecting...');
            const es = new EventSource(STREAM_URL);
            sseState.es = es;

            clearConnectingTimer();
            sseState.connectingTimer = setTimeout(() => {
              if (
                sseState.es &&
                sseState.es.readyState === EventSource.CONNECTING
              ) {
                console.warn('SSE stuck CONNECTING; recreating');
                recreateConnection();
              }
            }, 20000);

            es.onopen = () => {
              sseState.isConnecting = false;
              clearConnectingTimer();
              onActivity();
              startHeartbeat();
              console.log('SSE connected');
            };

            es.onerror = (error) => {
              console.warn('SSE error', error);
              onActivity();
              if (!sseState.es) return;
              if (sseState.es.readyState === EventSource.CLOSED) {
                cleanupES(false);
                scheduleReconnect('closed');
              } else if (sseState.es.readyState === EventSource.CONNECTING) {
                scheduleReconnect('connecting');
              }
            };

            es.addEventListener(EVENT_STDOUT, function (e) {
              onActivity();
              var data = JSON.parse(e.data);
              if (data.line) {
                if (term) {
                    term.appendLine(data.line);
                }
              }
            });

            es.addEventListener(EVENT_UPDATE, function (e) {
              onActivity();
              var data = JSON.parse(e.data);
              if (data.job && String(data.job.id) === '{{.Job.ID}}') {
                const stateString = jobStateToString(data.job.state);
                const stateClass = jobStateToClass(data.job.state);

                var stateEl = document.getElementById('state');
                if (stateEl) stateEl.innerText = stateString;

                const statusIcon = document.querySelector('.job-status');
                const statusText = document.getElementById('state');

                const stateClasses = [
                  'pending',
                  'Pending',
                  'in-progress',
                  'InProgress',
                  'completed',
                  'Completed',
                  'cancelled',
                  'Cancelled',
                  'error',
                  'Error',
                ];
                if (statusIcon && statusText) {
                  stateClasses.forEach((cls) => {
                    statusIcon.classList.remove(cls);
                    statusText.classList.remove(cls);
                  });
                  statusIcon.classList.add(stateClass);
                  statusText.classList.add(stateClass);
                }

                if (
                  stateString === 'Completed' ||
                  stateString === 'Cancelled' ||
                  stateString === 'Error'
                ) {
                  var cancelBtn = document.getElementById('cancel');
                  if (cancelBtn) cancelBtn.style.display = 'none';
                }

                if (data.job.completed_at) {
                  var completedAt = document.getElementById('completedAt');
                  if (completedAt)
                    completedAt.innerText = data.job.completed_at;
                }
                if (data.job.errored_at) {
                  var erroredAt = document.getElementById('erroredAt');
                  if (erroredAt) erroredAt.innerText = data.job.errored_at;
                }
              }
            });
          } catch (e) {
            console.error('SSE connect threw', e);
            sseState.isConnecting = false;
            scheduleReconnect('exception');
          }
        }

        function setupLifecycle() {
          if (sseState.lifecycleSetup) return;
          sseState.lifecycleSetup = true;

          window.addEventListener('online', () => {
            resetBackoff();
            connect();
          });
          window.addEventListener('offline', () => {
            cleanupES(false);
          });

          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
              resetBackoff();
              connect();
            }
          });

          window.addEventListener('focus', () => {
            resetBackoff();
            if (!sseState.es || sseState.es.readyState === EventSource.CLOSED) {
              connect();
            } else {
              const inactiveMs = Date.now() - sseState.lastActivityTs;
              if (inactiveMs > 15000) {
                recreateConnection();
              }
            }
          });

          window.addEventListener('pageshow', (e) => {
            resetBackoff();
            connect();
          });

          window.addEventListener('pagehide', () => {
            cleanupES(false);
          });

          window.addEventListener('beforeunload', () => {
            cleanupES(true);
          });
        }

        setupLifecycle();
        connect();
      });

      function cancelJob(e) {
        e.preventDefault();
        const id = e.target.getAttribute('data-id');
        fetch(`/job/${id}/cancel`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        })
          .then((response) => response.text())
          .then((result) => {
            console.log('Server responded:', result);
          })
          .catch((err) => console.error('Error:', err));
      }

      function jobStateToString(state) {
        // Handle both numeric and string states
        switch (state) {
          case 0:
          case 'pending':
          case 'Pending':
            return 'Pending';
          case 1:
          case 'in_progress':
          case 'InProgress':
            return 'InProgress';
          case 2:
          case 'completed':
          case 'Completed':
            return 'Completed';
          case 3:
          case 'cancelled':
          case 'Cancelled':
            return 'Cancelled';
          case 4:
          case 'error':
          case 'Error':
            return 'Error';
          default:
            return 'Unknown';
        }
      }

      function jobStateToClass(state) {
        // Handle both numeric and string states
        switch (state) {
          case 0:
          case 'pending':
          case 'Pending':
            return 'Pending';
          case 1:
          case 'in_progress':
          case 'InProgress':
            return 'InProgress';
          case 2:
          case 'completed':
          case 'Completed':
            return 'Completed';
          case 3:
          case 'cancelled':
          case 'Cancelled':
            return 'Cancelled';
          case 4:
          case 'error':
          case 'Error':
            return 'Error';
          default:
            return 'Pending';
        }
      }
    </script>
  </body>
</html>
{{ end }}
