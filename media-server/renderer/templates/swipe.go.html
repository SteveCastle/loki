{{ define "swipe" }}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- Viewport: cover entire screen, prevent zoom, extend into safe areas -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
    />

    <!-- iOS Web App (Add to Home Screen) - enables fullscreen mode -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="apple-mobile-web-app-title" content="Swipe" />
    <link rel="apple-touch-icon" href="/static/apple-touch-icon.png" />

    <!-- Android/Chrome theme -->
    <meta name="theme-color" content="#000000" />
    <meta name="mobile-web-app-capable" content="yes" />

    <!-- Prevent phone number detection -->
    <meta name="format-detection" content="telephone=no" />

    <!-- PWA Manifest for standalone mode -->
    <link rel="manifest" href="/swipe/manifest.json" />

    <title>Shrike Swipe</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }

      :root {
        --bg: #000;
        --accent: #00d9a5;
        --text: #fff;
        --text-dim: rgba(255, 255, 255, 0.6);
        --overlay: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.8) 0%,
          rgba(0, 0, 0, 0.4) 20%,
          transparent 50%
        );
        --safe-bottom: env(safe-area-inset-bottom, 0px);
        --safe-top: env(safe-area-inset-top, 0px);
        --safe-left: env(safe-area-inset-left, 0px);
        --safe-right: env(safe-area-inset-right, 0px);
      }

      html {
        height: 100%;
        height: -webkit-fill-available;
        height: 100dvh;
        overflow: hidden;
        background: var(--bg);
      }

      body {
        min-height: 100%;
        min-height: -webkit-fill-available;
        min-height: 100dvh;
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: var(--bg);
        font-family: "JetBrains Mono", monospace;
        color: var(--text);
        touch-action: none;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: none;
        /* Prevent pull-to-refresh and overscroll */
        overscroll-behavior-y: contain;
        position: fixed;
        inset: 0;
      }

      .swipe-container {
        position: fixed;
        inset: 0;
        overflow: hidden;
        perspective: 1000px;
        perspective-origin: center center;
      }

      .swipe-track {
        position: absolute;
        inset: 0;
        will-change: transform;
        transform-style: preserve-3d;
      }

      .swipe-track.dragging {
        transition: none;
      }

      .swipe-track.transitioning {
        transition: transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      .swipe-track.snapping {
        transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      .swipe-item {
        position: absolute;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--bg);
        overflow: hidden;
        transition: transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                    opacity 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                    filter 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        will-change: transform, opacity;
      }

      .swipe-item.dragging {
        transition: none;
      }

      /* Stack effect for adjacent items - subtle brightness/blur for depth */
      .swipe-item[data-offset="1"] {
        filter: brightness(0.65) blur(1px);
      }

      .swipe-item[data-offset="-1"] {
        filter: brightness(0.8) blur(0.5px);
      }

      /* Smoother transitions when not dragging */
      .swipe-item:not(.dragging) {
        transition: transform 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                    opacity 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94),
                    filter 0.45s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }

      .swipe-item::after {
        content: "";
        position: absolute;
        inset: 0;
        background: var(--overlay);
        pointer-events: none;
        z-index: 1;
      }

      .swipe-media {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: var(--bg);
        will-change: transform;
        touch-action: none;
      }

      .swipe-media.cover {
        object-fit: cover;
      }

      /* Loading state */
      .swipe-item.loading .swipe-media {
        opacity: 0;
      }

      .swipe-item.loading::before {
        content: "";
        position: absolute;
        width: 40px;
        height: 40px;
        border: 3px solid rgba(255, 255, 255, 0.1);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        z-index: 5;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Info overlay */
      .swipe-info {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 20px;
        padding-bottom: calc(20px + var(--safe-bottom));
        z-index: 10;
        pointer-events: none;
      }

      .swipe-info-content {
        max-width: 85%;
      }

      .swipe-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 12px;
      }

      .swipe-tag {
        font-size: 11px;
        font-weight: 500;
        padding: 4px 10px;
        background: rgba(0, 217, 165, 0.15);
        border: 1px solid rgba(0, 217, 165, 0.3);
        border-radius: 20px;
        color: var(--accent);
        text-transform: lowercase;
        letter-spacing: 0.3px;
      }

      .swipe-description {
        font-size: 13px;
        line-height: 1.5;
        color: var(--text);
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .swipe-path {
        font-size: 10px;
        color: var(--text-dim);
        margin-top: 8px;
        opacity: 0.7;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }

      /* Side actions */
      .swipe-actions {
        position: absolute;
        right: 12px;
        bottom: 120px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        z-index: 10;
        padding-bottom: var(--safe-bottom);
      }

      .action-btn {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        color: var(--text);
        font-size: 20px;
      }

      .action-btn:active {
        transform: scale(0.9);
        background: rgba(0, 217, 165, 0.3);
      }

      .action-btn.active {
        background: var(--accent);
        color: #000;
        border-color: var(--accent);
      }

      /* Progress indicator */
      .progress-bar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: rgba(255, 255, 255, 0.1);
        z-index: 20;
        padding-top: var(--safe-top);
      }

      .progress-fill {
        height: 100%;
        background: var(--accent);
        width: 0%;
        transition: width 0.3s ease;
      }

      /* Header */
      .swipe-header {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: calc(12px + var(--safe-top)) 16px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        z-index: 15;
        background: linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0.6) 0%,
          transparent 100%
        );
      }

      .swipe-logo {
        font-size: 16px;
        font-weight: 500;
        color: var(--accent);
        letter-spacing: 2px;
        text-transform: uppercase;
      }

      .swipe-counter {
        font-size: 12px;
        color: var(--text-dim);
      }

      .header-btn {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: var(--text);
        font-size: 16px;
        text-decoration: none;
        transition: background 0.2s;
      }

      .header-btn:active {
        background: rgba(255, 255, 255, 0.2);
      }

      /* Empty state */
      .empty-state {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 40px;
        z-index: 5;
      }

      .empty-icon {
        font-size: 64px;
        margin-bottom: 24px;
        opacity: 0.3;
      }

      .empty-title {
        font-size: 20px;
        font-weight: 500;
        margin-bottom: 8px;
      }

      .empty-text {
        font-size: 14px;
        color: var(--text-dim);
        max-width: 280px;
        line-height: 1.5;
      }

      /* Video controls */
      .video-controls {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 5;
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
      }

      .swipe-item.paused .video-controls {
        opacity: 1;
      }

      .play-icon {
        width: 80px;
        height: 80px;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(10px);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 32px;
        border: 2px solid rgba(255, 255, 255, 0.2);
      }

      /* Video scrubber */
      .video-scrubber {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 0 16px calc(16px + var(--safe-bottom));
        z-index: 8;
        opacity: 0;
        transform: translateY(10px);
        transition: opacity 0.3s, transform 0.3s;
        pointer-events: none;
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.7) 0%,
          transparent 100%
        );
      }

      .video-scrubber.show {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }

      .scrubber-time {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: var(--text-dim);
        margin-bottom: 8px;
        font-variant-numeric: tabular-nums;
      }

      .scrubber-track {
        position: relative;
        height: 32px;
        display: flex;
        align-items: center;
        cursor: pointer;
        touch-action: none;
      }

      .scrubber-bar {
        position: absolute;
        left: 0;
        right: 0;
        height: 4px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 2px;
        overflow: hidden;
      }

      .scrubber-track:hover .scrubber-bar,
      .scrubber-track.active .scrubber-bar {
        height: 6px;
      }

      .scrubber-progress {
        height: 100%;
        background: var(--accent);
        border-radius: 2px;
        width: 0%;
        transition: width 0.1s linear;
      }

      .scrubber-track.active .scrubber-progress {
        transition: none;
      }

      .scrubber-buffered {
        position: absolute;
        height: 100%;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 2px;
        width: 0%;
      }

      .scrubber-handle {
        position: absolute;
        width: 16px;
        height: 16px;
        background: var(--accent);
        border-radius: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        left: 0%;
        opacity: 0;
        transition: opacity 0.2s, transform 0.15s;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      }

      .scrubber-track:hover .scrubber-handle,
      .scrubber-track.active .scrubber-handle {
        opacity: 1;
      }

      .scrubber-track.active .scrubber-handle {
        transform: translate(-50%, -50%) scale(1.2);
      }

      .scrubber-preview {
        position: absolute;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        color: var(--text);
        opacity: 0;
        transition: opacity 0.15s;
        pointer-events: none;
        font-variant-numeric: tabular-nums;
      }

      .scrubber-track.active .scrubber-preview {
        opacity: 1;
      }

      /* Swipe hint animation */
      .swipe-hint {
        position: absolute;
        bottom: calc(100px + var(--safe-bottom));
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        color: var(--text-dim);
        font-size: 12px;
        z-index: 5;
        animation: fadeInOut 3s ease-in-out forwards;
        pointer-events: none;
      }

      .swipe-hint-arrow {
        font-size: 24px;
        animation: bounce 1.5s infinite;
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-8px);
        }
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
        }
        20% {
          opacity: 1;
        }
        80% {
          opacity: 1;
        }
        100% {
          opacity: 0;
          display: none;
        }
      }

      /* Filter modal */
      .filter-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.95);
        z-index: 100;
        display: none;
        flex-direction: column;
        padding: calc(20px + var(--safe-top)) 20px
          calc(20px + var(--safe-bottom));
      }

      .filter-modal.show {
        display: flex;
      }

      .filter-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .filter-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--text);
      }

      .filter-close {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s;
      }

      .filter-close:active {
        background: rgba(255, 255, 255, 0.15);
        transform: scale(0.95);
      }

      .filter-input {
        width: 100%;
        padding: 14px 16px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        color: var(--text);
        font-family: inherit;
        font-size: 14px;
        outline: none;
        margin-bottom: 16px;
      }

      .filter-input:focus {
        border-color: var(--accent);
        background: rgba(0, 217, 165, 0.05);
      }

      .filter-input::placeholder {
        color: var(--text-dim);
      }

      .filter-apply {
        width: 100%;
        padding: 16px;
        background: var(--accent);
        border: none;
        border-radius: 12px;
        color: #000;
        font-family: inherit;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        margin-top: auto;
        transition: all 0.2s;
        box-shadow: 0 4px 12px rgba(0, 217, 165, 0.3);
      }

      .filter-apply:active {
        transform: scale(0.98);
        box-shadow: 0 2px 8px rgba(0, 217, 165, 0.2);
      }

      /* Selected tags chips */
      .selected-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 20px;
        padding: 16px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        min-height: 56px;
        align-items: center;
      }

      .selected-tags:empty::before {
        content: "No tags selected";
        color: var(--text-dim);
        font-size: 13px;
        opacity: 0.6;
      }

      .selected-tag-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 12px;
        background: rgba(0, 217, 165, 0.15);
        border: 1px solid rgba(0, 217, 165, 0.3);
        border-radius: 20px;
        color: var(--accent);
        font-size: 13px;
        font-weight: 500;
        animation: chipAppear 0.2s ease-out;
      }

      @keyframes chipAppear {
        from {
          opacity: 0;
          transform: scale(0.8);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .selected-tag-chip button {
        background: none;
        border: none;
        color: var(--accent);
        cursor: pointer;
        padding: 0;
        font-size: 16px;
        line-height: 1;
        opacity: 0.7;
        transition: opacity 0.15s;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .selected-tag-chip button:active {
        opacity: 1;
      }

      .clear-all-tags {
        display: inline-flex;
        align-items: center;
        padding: 8px 12px;
        background: rgba(255, 107, 107, 0.1);
        border: 1px solid rgba(255, 107, 107, 0.3);
        border-radius: 20px;
        color: #ff6b6b;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.15s;
      }

      .clear-all-tags:active {
        background: rgba(255, 107, 107, 0.2);
      }

      /* Tag search */
      .tag-search {
        width: 100%;
        padding: 14px 16px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        color: var(--text);
        font-family: inherit;
        font-size: 14px;
        outline: none;
        margin-bottom: 16px;
        transition: all 0.2s;
      }

      .tag-search:focus {
        border-color: var(--accent);
        background: rgba(0, 217, 165, 0.08);
        box-shadow: 0 0 0 3px rgba(0, 217, 165, 0.1);
      }

      .tag-search::placeholder {
        color: var(--text-dim);
      }

      .tag-list {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        margin-bottom: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.3);
        /* Smooth scrolling on iOS */
        -webkit-overflow-scrolling: touch;
      }

      /* Hide scrollbar on webkit browsers */
      .tag-list::-webkit-scrollbar {
        width: 6px;
      }

      .tag-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .tag-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .tag-list::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .tag-category-section {
        margin-bottom: 12px;
      }

      .tag-category-section:last-child {
        margin-bottom: 0;
      }

      .tag-category-header {
        position: sticky;
        top: 0;
        background: rgba(0, 0, 0, 0.98);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        padding: 10px 16px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 1.2px;
        color: var(--accent);
        border-bottom: 1px solid rgba(0, 217, 165, 0.15);
        z-index: 10;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .tag-category-items {
        padding: 8px;
      }

      .tag-item {
        padding: 12px 14px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid transparent;
        border-radius: 10px;
        color: var(--text-dim);
        cursor: pointer;
        margin-bottom: 6px;
        transition: all 0.15s;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 14px;
      }

      .tag-item:last-child {
        margin-bottom: 0;
      }

      .tag-item:active {
        transform: scale(0.98);
      }

      .tag-item.selected {
        background: rgba(0, 217, 165, 0.15);
        border-color: rgba(0, 217, 165, 0.3);
        color: var(--accent);
      }

      .tag-item .tag-count {
        font-size: 11px;
        opacity: 0.6;
        background: rgba(255, 255, 255, 0.05);
        padding: 2px 8px;
        border-radius: 10px;
      }

      .tag-item.selected .tag-count {
        background: rgba(0, 217, 165, 0.2);
      }

      .tag-list-empty {
        text-align: center;
        padding: 40px 20px;
        color: var(--text-dim);
        font-size: 13px;
      }

      /* Double tap heart animation */
      .heart-animation {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-size: 100px;
        z-index: 50;
        pointer-events: none;
        opacity: 0;
      }

      .heart-animation.show {
        animation: heartPop 0.8s ease-out forwards;
      }

      @keyframes heartPop {
        0% {
          transform: translate(-50%, -50%) scale(0);
          opacity: 1;
        }
        15% {
          transform: translate(-50%, -50%) scale(1.2);
          opacity: 1;
        }
        30% {
          transform: translate(-50%, -50%) scale(0.95);
          opacity: 1;
        }
        45% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }

      /* iOS Install Prompt */
      .install-prompt {
        position: fixed;
        bottom: calc(20px + var(--safe-bottom));
        left: 16px;
        right: 16px;
        background: rgba(30, 30, 30, 0.95);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 16px;
        padding: 16px;
        z-index: 200;
        display: none;
        animation: slideUp 0.4s ease-out;
      }

      .install-prompt.show {
        display: block;
      }

      @keyframes slideUp {
        from {
          transform: translateY(100%);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .install-prompt-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
      }

      .install-prompt-title {
        font-size: 15px;
        font-weight: 500;
        color: var(--text);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .install-prompt-close {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        color: var(--text-dim);
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .install-prompt-body {
        font-size: 13px;
        color: var(--text-dim);
        line-height: 1.5;
      }

      .install-prompt-steps {
        margin-top: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--text);
      }

      .install-prompt-steps .share-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 28px;
        height: 28px;
        background: var(--accent);
        color: #000;
        border-radius: 6px;
        font-size: 16px;
      }

      /* Standalone mode indicator */
      .standalone-mode .install-prompt {
        display: none !important;
      }

      /* Hide header in standalone for more immersion */
      @media all and (display-mode: standalone) {
        .swipe-header {
          padding-top: calc(8px + var(--safe-top));
        }
      }
    </style>
  </head>
  <body>
    <div class="swipe-container" id="swipeContainer">
      <div class="swipe-header">
        <a href="/media" class="header-btn" title="Back to browser">‚Üê</a>
        <span class="swipe-logo">Swipe</span>
        <button class="header-btn" id="filterBtn" title="Filter">‚öô</button>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <div class="swipe-track" id="swipeTrack"></div>

      <div class="swipe-actions" id="swipeActions" style="display: none">
        <button class="action-btn" id="likeBtn" title="Like">‚ô•</button>
        <button class="action-btn" id="openBtn" title="Open in browser">
          ‚Üó
        </button>
        <button class="action-btn" id="fitBtn" title="Toggle fit mode">
          ‚õ∂
        </button>
      </div>

      <div class="swipe-hint" id="swipeHint">
        <span class="swipe-hint-arrow">‚Üë</span>
        <span>Swipe up for more</span>
      </div>

      <div class="empty-state" id="emptyState" style="display: none">
        <div class="empty-icon">üì∑</div>
        <div class="empty-title">No media found</div>
        <div class="empty-text">
          Try adjusting your filter or add some media to your library.
        </div>
      </div>

      <div class="heart-animation" id="heartAnimation">‚ù§Ô∏è</div>

      <!-- iOS Install Prompt -->
      <div class="install-prompt" id="installPrompt">
        <div class="install-prompt-header">
          <div class="install-prompt-title">
            <span>üì±</span>
            <span>Install Swipe</span>
          </div>
          <button class="install-prompt-close" id="installPromptClose">
            ‚úï
          </button>
        </div>
        <div class="install-prompt-body">
          Add to your home screen for a fullscreen experience with no browser
          bars.
        </div>
        <div class="install-prompt-steps">
          <span class="share-icon">‚Üë</span>
          <span>Tap Share, then "Add to Home Screen"</span>
        </div>
      </div>
    </div>

    <div class="filter-modal" id="filterModal">
      <div class="filter-header">
        <span class="filter-title">Filter by Tags</span>
        <button class="filter-close" id="filterClose">‚úï</button>
      </div>

      <div class="selected-tags" id="selectedTags">
        <!-- Selected tag chips will be inserted here -->
      </div>

      <input
        type="text"
        class="tag-search"
        id="tagSearch"
        placeholder="Search tags..."
        autocomplete="off"
      />

      <div class="tag-list" id="tagList">
        <div class="tag-list-empty">Loading tags...</div>
      </div>

      <button class="filter-apply" id="filterApply">Apply Filter</button>
    </div>

    <script>
      // State
      let items = [];
      let currentIndex = 0;
      let isLoading = false;
      let isPreloading = false;
      let hasMore = true;
      let searchQuery = "{{.SearchQuery}}";
      let fitMode = "contain"; // contain or cover
      // Liked items are now managed via database tags (Swipe/Favorites)
      // This Set is used for UI state only
      let likedItems = new Set();

      // Generate a session seed for deterministic shuffle
      // This changes on each page load but stays consistent during pagination
      // Uses crypto.getRandomValues for high-quality randomness
      const SESSION_SEED_KEY = "swipe_session_seed";
      let sessionSeed = sessionStorage.getItem(SESSION_SEED_KEY);
      if (!sessionSeed) {
        // Generate a cryptographically strong random seed
        const randomArray = new Uint32Array(1);
        crypto.getRandomValues(randomArray);
        sessionSeed = randomArray[0].toString();
        sessionStorage.setItem(SESSION_SEED_KEY, sessionSeed);
      }

      // DOM elements
      const container = document.getElementById("swipeContainer");
      const track = document.getElementById("swipeTrack");
      const progressFill = document.getElementById("progressFill");
      const swipeActions = document.getElementById("swipeActions");
      const emptyState = document.getElementById("emptyState");
      const swipeHint = document.getElementById("swipeHint");
      const heartAnimation = document.getElementById("heartAnimation");
      const filterModal = document.getElementById("filterModal");
      const tagSearch = document.getElementById("tagSearch");
      const tagList = document.getElementById("tagList");
      const selectedTagsContainer = document.getElementById("selectedTags");
      const likeBtn = document.getElementById("likeBtn");
      const openBtn = document.getElementById("openBtn");
      const fitBtn = document.getElementById("fitBtn");
      const installPrompt = document.getElementById("installPrompt");
      const installPromptClose = document.getElementById("installPromptClose");

      // Tag filter state
      let allTags = [];
      let selectedTags = new Set();
      let filteredTags = [];

      // Storage key for persisting selected tags
      const SELECTED_TAGS_KEY = "swipe_selected_tags";

      // Build tag query from selected tags
      function buildTagQuery() {
        if (selectedTags.size === 0) return "";
        const tagQueries = Array.from(selectedTags).map(
          (tag) => `tag:"${tag}"`
        );
        return tagQueries.join(" OR ");
      }

      // Load selected tags from localStorage
      function loadSelectedTags() {
        try {
          const stored = localStorage.getItem(SELECTED_TAGS_KEY);
          if (stored) {
            const tags = JSON.parse(stored);
            tags.forEach(tag => selectedTags.add(tag));
          }
        } catch (e) {
          console.error("Failed to load selected tags:", e);
        }
      }

      // Save selected tags to localStorage
      function saveSelectedTags() {
        try {
          localStorage.setItem(SELECTED_TAGS_KEY, JSON.stringify(Array.from(selectedTags)));
        } catch (e) {
          console.error("Failed to save selected tags:", e);
        }
      }

      // Parse initial search query for tags
      (function parseInitialQuery() {
        // First, try to load from localStorage
        loadSelectedTags();

        // If no tags in localStorage and we have a search query, parse it
        if (selectedTags.size === 0 && searchQuery) {
          // Match patterns like tag:"something" in the query
          const tagPattern = /tag:"([^"]+)"/g;
          let match;
          while ((match = tagPattern.exec(searchQuery)) !== null) {
            selectedTags.add(match[1]);
          }
          // Save parsed tags to localStorage
          if (selectedTags.size > 0) {
            saveSelectedTags();
          }
        } else if (selectedTags.size > 0) {
          // If we loaded tags from localStorage, update searchQuery to match
          searchQuery = buildTagQuery();
        }
      })();

      // iOS/Standalone detection
      const isIOS =
        /iPad|iPhone|iPod/.test(navigator.userAgent) ||
        (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
      const isStandalone =
        window.navigator.standalone === true ||
        window.matchMedia("(display-mode: standalone)").matches;
      const installPromptDismissed = localStorage.getItem(
        "swipeInstallDismissed"
      );

      // Show install prompt for iOS Safari users (not in standalone mode)
      if (isIOS && !isStandalone && !installPromptDismissed) {
        // Delay showing the prompt slightly for better UX
        setTimeout(() => {
          installPrompt.classList.add("show");
        }, 2000);
      }

      // Mark body as standalone mode for CSS
      if (isStandalone) {
        document.body.classList.add("standalone-mode");
      }

      // Handle install prompt close
      installPromptClose.addEventListener("click", () => {
        installPrompt.classList.remove("show");
        localStorage.setItem("swipeInstallDismissed", "true");
      });

      // Touch tracking
      let touchStartY = 0;
      let touchCurrentY = 0;
      let isDragging = false;
      let lastTapTime = 0;
      let touchStartTime = 0;
      let lastTouchY = 0;
      let lastTouchTime = 0;
      let velocityY = 0;

      // Pan and zoom state
      let currentScale = 1;
      let currentTranslateX = 0;
      let currentTranslateY = 0;
      let isMultiTouch = false;
      let initialDistance = 0;
      let initialScale = 1;
      let initialTouchCenter = { x: 0, y: 0 };
      let lastTouchCenter = { x: 0, y: 0 };

      // Initialize
      async function init() {
        const savedPath = getSavedPosition();

        // Load first item immediately for fast initial render
        await loadMore(1);

        if (items.length > 0) {
          // Hide empty state and show content
          emptyState.style.display = "none";

          // Try to restore to saved position
          let restoredIndex = 0;
          if (savedPath) {
            // Look for the saved path in loaded items
            let foundIndex = items.findIndex((item) => item.path === savedPath);

            // If not found, keep loading until we find it or run out
            while (foundIndex === -1 && hasMore && items.length < 200) {
              await loadMore(20);
              foundIndex = items.findIndex((item) => item.path === savedPath);
            }

            if (foundIndex !== -1) {
              restoredIndex = foundIndex;
              // Hide the hint since user is resuming
              if (swipeHint) swipeHint.style.display = "none";
            }
          }

          currentIndex = restoredIndex;
          renderItems();
          swipeActions.style.display = "flex";
          updateProgress();
          updateLikeButton();
          savePosition(); // Save initial position

          // Load next batch in background for smoother experience
          // Increased batch size for better buffering
          if (!savedPath && hasMore) {
            loadMore(20, true);
          }

          // Trigger intelligent preloading
          checkAndPreload();
        } else {
          // Show empty state and hide content
          emptyState.style.display = "flex";
          swipeActions.style.display = "none";
          swipeHint.style.display = "none";
        }
      }

      // Load more items from API
      async function loadMore(limit = 15, preload = false) {
        // Use separate flag for preloading to allow background loading
        if (preload) {
          if (isPreloading || !hasMore) return;
          isPreloading = true;
        } else {
          if (isLoading || !hasMore) return;
          isLoading = true;
        }

        try {
          const params = new URLSearchParams({
            offset: items.length,
            limit: limit,
            seed: sessionSeed,
          });
          if (searchQuery) {
            params.set("q", searchQuery);
          }

          const response = await fetch(`/swipe/api?${params}`);
          const data = await response.json();

          items = items.concat(data.items || []);
          hasMore = data.has_more;
        } catch (err) {
          console.error("Failed to load items:", err);
        } finally {
          if (preload) {
            isPreloading = false;
          } else {
            isLoading = false;
          }
        }
      }

      // Intelligent preloading - loads next batch when getting close
      function checkAndPreload() {
        if (!hasMore || isPreloading) return;

        const itemsRemaining = items.length - currentIndex;

        // Aggressive preloading: load when 3 items remain
        // Tighter trigger for smoother experience
        if (itemsRemaining <= 3) {
          loadMore(15, true);
        }
      }

      // Render current and adjacent items
      function renderItems() {
        track.innerHTML = "";
        scrubberVisible = false;

        // Render previous, current, and next items
        [-1, 0, 1].forEach((offset) => {
          const index = currentIndex + offset;
          if (index < 0 || index >= items.length) return;

          const item = items[index];
          const el = createItemElement(item, offset);

          // Apply depth effect with scale, position, and filters
          const scale = offset === 0 ? 1 : 0.9;
          const translateY = offset * 100;
          const translateZ = offset === 0 ? 0 : -100;
          const opacity = offset === 0 ? 1 : 0.6;
          const brightness = offset === 0 ? 1 : (offset === 1 ? 0.65 : 0.8);
          const blur = offset === 0 ? 0 : (offset === 1 ? 1 : 0.5);

          el.style.transform = `translateY(${translateY}%) scale(${scale}) translateZ(${translateZ}px)`;
          el.style.opacity = opacity;
          el.style.filter = `brightness(${brightness}) blur(${blur}px)`;
          el.style.zIndex = offset === 0 ? 10 : (offset < 0 ? 5 : 0);

          track.appendChild(el);

          // Set up video listeners for current item
          if (offset === 0) {
            setupVideoListeners(el);
          }
        });
      }

      // Create item DOM element
      function createItemElement(item, offset) {
        const div = document.createElement("div");
        div.className = "swipe-item loading";
        div.dataset.path = item.path;
        div.dataset.offset = offset;

        const isVideo = isVideoFile(item.path);
        let mediaEl;

        if (isVideo) {
          mediaEl = document.createElement("video");
          mediaEl.className = `swipe-media ${
            fitMode === "cover" ? "cover" : ""
          }`;
          mediaEl.muted = true;
          mediaEl.loop = true;
          mediaEl.playsInline = true;
          mediaEl.preload = offset === 0 ? "auto" : "metadata";

          mediaEl.onloadeddata = () => {
            div.classList.remove("loading");
            if (offset === 0) mediaEl.play().catch(() => {});
          };
          mediaEl.onerror = () => {
            div.classList.remove("loading");
            div.innerHTML +=
              '<div style="position:absolute;color:var(--text-dim);font-size:12px;">Failed to load video</div>';
          };

          mediaEl.src = getMediaUrl(item.path);

          // Add video controls overlay
          const controls = document.createElement("div");
          controls.className = "video-controls";
          controls.innerHTML = '<div class="play-icon">‚ñ∂</div>';
          div.appendChild(controls);

          // Add video scrubber
          const scrubber = document.createElement("div");
          scrubber.className = "video-scrubber";
          scrubber.innerHTML = `
            <div class="scrubber-time">
              <span class="scrubber-current">0:00</span>
              <span class="scrubber-duration">0:00</span>
            </div>
            <div class="scrubber-track">
              <div class="scrubber-bar">
                <div class="scrubber-buffered"></div>
                <div class="scrubber-progress"></div>
              </div>
              <div class="scrubber-handle"></div>
              <div class="scrubber-preview">0:00</div>
            </div>
          `;
          div.appendChild(scrubber);
        } else {
          mediaEl = document.createElement("img");
          mediaEl.className = `swipe-media ${
            fitMode === "cover" ? "cover" : ""
          }`;
          mediaEl.loading = offset === 0 ? "eager" : "lazy";
          // Prioritize first image load
          if (offset === 0) {
            mediaEl.fetchPriority = "high";
          }

          mediaEl.onload = () => div.classList.remove("loading");
          mediaEl.onerror = () => {
            div.classList.remove("loading");
            div.innerHTML +=
              '<div style="position:absolute;color:var(--text-dim);font-size:12px;">Failed to load image</div>';
          };

          mediaEl.src = getMediaUrl(item.path);
        }

        div.appendChild(mediaEl);

        // Info overlay
        const info = document.createElement("div");
        info.className = "swipe-info";
        info.innerHTML = `
          <div class="swipe-info-content">
            ${
              item.tags && item.tags.length > 0
                ? `
              <div class="swipe-tags">
                ${item.tags
                  .slice(0, 5)
                  .map(
                    (t) =>
                      `<span class="swipe-tag">${escapeHtml(t.label)}</span>`
                  )
                  .join("")}
              </div>
            `
                : ""
            }
            ${
              item.description
                ? `<div class="swipe-description">${escapeHtml(
                    item.description
                  )}</div>`
                : ""
            }
            <div class="swipe-path">${escapeHtml(getFileName(item.path))}</div>
          </div>
        `;
        div.appendChild(info);

        return div;
      }

      // Position persistence
      const POSITION_STORAGE_KEY = "swipe_last_position";

      function savePosition() {
        if (items.length === 0 || currentIndex >= items.length) return;
        const currentPath = items[currentIndex].path;
        try {
          localStorage.setItem(
            POSITION_STORAGE_KEY,
            JSON.stringify({
              path: currentPath,
              query: searchQuery,
              timestamp: Date.now(),
            })
          );
        } catch (e) {}
      }

      function getSavedPosition() {
        try {
          const stored = localStorage.getItem(POSITION_STORAGE_KEY);
          if (!stored) return null;
          const data = JSON.parse(stored);
          // Only restore if same filter query and within last 7 days
          const weekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
          if (data.query === searchQuery && data.timestamp > weekAgo) {
            return data.path;
          }
        } catch (e) {}
        return null;
      }

      // Navigation
      function goToIndex(index) {
        if (index < 0 || index >= items.length) return;

        // Reset pan and zoom transforms when navigating
        resetMediaTransform();

        // Pause current video if any
        const currentVideo = track.querySelector('[data-offset="0"] video');
        if (currentVideo) currentVideo.pause();

        currentIndex = index;

        // Add transition class for smooth navigation
        track.classList.add("transitioning");
        setTimeout(() => track.classList.remove("transitioning"), 450);

        renderItems();
        updateProgress();
        updateLikeButton();

        // Save position for session restore
        savePosition();

        // Play new video if any
        setTimeout(() => {
          const newVideo = track.querySelector('[data-offset="0"] video');
          if (newVideo) newVideo.play().catch(() => {});
        }, 50);

        // Intelligent preloading
        checkAndPreload();

        // Hide hint after first swipe
        if (swipeHint) swipeHint.style.display = "none";
      }

      function goNext() {
        if (currentIndex < items.length - 1) {
          goToIndex(currentIndex + 1);
        }
      }

      function goPrev() {
        if (currentIndex > 0) {
          goToIndex(currentIndex - 1);
        }
      }

      // Update progress bar
      function updateProgress() {
        const progress =
          items.length > 1 ? ((currentIndex + 1) / items.length) * 100 : 100;
        progressFill.style.width = `${progress}%`;
      }

      // Update like button state
      async function updateLikeButton() {
        if (items.length === 0) return;
        const currentPath = items[currentIndex].path;

        // Check if the current item has the Favorites tag in Swipe category
        try {
          const response = await fetch(
            `/media/has-tag?media_path=${encodeURIComponent(
              currentPath
            )}&tag_label=Favorites&category_label=Swipe`
          );
          if (response.ok) {
            const data = await response.json();
            if (data.has_tag) {
              likeBtn.classList.add("active");
              likedItems.add(currentPath);
            } else {
              likeBtn.classList.remove("active");
              likedItems.delete(currentPath);
            }
          }
        } catch (err) {
          console.error("Failed to check like status:", err);
        }
      }

      // Toggle like
      async function toggleLike() {
        if (items.length === 0) return;
        const currentPath = items[currentIndex].path;

        const isCurrentlyLiked = likedItems.has(currentPath);
        const action = isCurrentlyLiked ? "remove" : "add";

        try {
          const response = await fetch("/media/tag", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              media_path: currentPath,
              tag_label: "Favorites",
              category_label: "Swipe",
              action: action,
            }),
          });

          if (response.ok) {
            if (isCurrentlyLiked) {
              likedItems.delete(currentPath);
              likeBtn.classList.remove("active");
            } else {
              likedItems.add(currentPath);
              likeBtn.classList.add("active");
              showHeartAnimation();
            }
          } else {
            console.error("Failed to toggle like:", await response.text());
          }
        } catch (err) {
          console.error("Failed to toggle like:", err);
        }
      }

      // Show heart animation
      function showHeartAnimation() {
        heartAnimation.classList.remove("show");
        void heartAnimation.offsetWidth; // Trigger reflow
        heartAnimation.classList.add("show");
      }

      // Toggle fit mode
      function toggleFitMode() {
        fitMode = fitMode === "contain" ? "cover" : "contain";
        const mediaEls = track.querySelectorAll(".swipe-media");
        mediaEls.forEach((el) => {
          if (fitMode === "cover") {
            el.classList.add("cover");
          } else {
            el.classList.remove("cover");
          }
        });
      }

      // Open current item in browser
      function openInBrowser() {
        if (items.length === 0) return;
        const currentPath = items[currentIndex].path;
        window.open(
          `/media?q=path:"${encodeURIComponent(currentPath)}"`,
          "_blank"
        );
      }

      // Toggle video pause/play
      function toggleVideoPause() {
        const item = track.querySelector('[data-offset="0"]');
        if (!item) return;
        const video = item.querySelector("video");
        if (!video) return;

        if (video.paused) {
          video.play();
          item.classList.remove("paused");
          hideScrubber();
        } else {
          video.pause();
          item.classList.add("paused");
          showScrubber();
        }
      }

      // Video scrubber state
      let scrubberVisible = false;
      let scrubberHideTimeout = null;
      let isScrubbing = false;
      let scrubStartX = 0;

      function formatTime(seconds) {
        if (!isFinite(seconds) || isNaN(seconds)) return "0:00";
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      function showScrubber() {
        const item = track.querySelector('[data-offset="0"]');
        if (!item) return;
        const scrubber = item.querySelector(".video-scrubber");
        if (!scrubber) return;

        scrubber.classList.add("show");
        scrubberVisible = true;

        // Auto-hide after 3 seconds if video is playing
        clearTimeout(scrubberHideTimeout);
        const video = item.querySelector("video");
        if (video && !video.paused) {
          scrubberHideTimeout = setTimeout(hideScrubber, 3000);
        }
      }

      function hideScrubber() {
        if (isScrubbing) return;
        const item = track.querySelector('[data-offset="0"]');
        if (!item) return;
        const scrubber = item.querySelector(".video-scrubber");
        if (!scrubber) return;

        scrubber.classList.remove("show");
        scrubberVisible = false;
        clearTimeout(scrubberHideTimeout);
      }

      function updateScrubberProgress() {
        const item = track.querySelector('[data-offset="0"]');
        if (!item) return;
        const video = item.querySelector("video");
        const scrubber = item.querySelector(".video-scrubber");
        if (!video || !scrubber) return;

        const progress = scrubber.querySelector(".scrubber-progress");
        const handle = scrubber.querySelector(".scrubber-handle");
        const currentTime = scrubber.querySelector(".scrubber-current");
        const duration = scrubber.querySelector(".scrubber-duration");
        const buffered = scrubber.querySelector(".scrubber-buffered");

        if (video.duration) {
          const percent = (video.currentTime / video.duration) * 100;
          progress.style.width = `${percent}%`;
          handle.style.left = `${percent}%`;
          currentTime.textContent = formatTime(video.currentTime);
          duration.textContent = formatTime(video.duration);

          // Update buffered progress
          if (video.buffered.length > 0) {
            const bufferedEnd = video.buffered.end(video.buffered.length - 1);
            const bufferedPercent = (bufferedEnd / video.duration) * 100;
            buffered.style.width = `${bufferedPercent}%`;
          }
        }
      }

      function setupVideoListeners(item) {
        const video = item.querySelector("video");
        if (!video) return;

        video.addEventListener("timeupdate", updateScrubberProgress);
        video.addEventListener("loadedmetadata", updateScrubberProgress);
      }

      function handleScrubStart(e) {
        const scrubberTrack = e.target.closest(".scrubber-track");
        if (!scrubberTrack) return;

        e.stopPropagation();
        isScrubbing = true;
        scrubberTrack.classList.add("active");
        clearTimeout(scrubberHideTimeout);

        const touch = e.touches ? e.touches[0] : e;
        scrubStartX = touch.clientX;

        handleScrubMove(e);
      }

      function handleScrubMove(e) {
        if (!isScrubbing) return;

        const item = track.querySelector('[data-offset="0"]');
        if (!item) return;

        const scrubberTrack = item.querySelector(".scrubber-track");
        const video = item.querySelector("video");
        const preview = item.querySelector(".scrubber-preview");
        if (!scrubberTrack || !video || !video.duration) return;

        e.preventDefault();
        e.stopPropagation();

        const touch = e.touches ? e.touches[0] : e;
        const rect = scrubberTrack.getBoundingClientRect();
        let percent = (touch.clientX - rect.left) / rect.width;
        percent = Math.max(0, Math.min(1, percent));

        const newTime = percent * video.duration;
        video.currentTime = newTime;

        // Update preview
        if (preview) {
          preview.textContent = formatTime(newTime);
          preview.style.left = `${percent * 100}%`;
        }

        updateScrubberProgress();
      }

      function handleScrubEnd(e) {
        if (!isScrubbing) return;

        isScrubbing = false;

        const item = track.querySelector('[data-offset="0"]');
        if (item) {
          const scrubberTrack = item.querySelector(".scrubber-track");
          if (scrubberTrack) {
            scrubberTrack.classList.remove("active");
          }
        }

        // Auto-hide after scrubbing if video is playing
        const video = item?.querySelector("video");
        if (video && !video.paused) {
          scrubberHideTimeout = setTimeout(hideScrubber, 2000);
        }
      }

      // Pan and zoom helper functions
      function getTouchDistance(touch1, touch2) {
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function getTouchCenter(touch1, touch2) {
        return {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2,
        };
      }

      function applyMediaTransform(mediaEl) {
        if (!mediaEl) return;
        mediaEl.style.transform = `translate(${currentTranslateX}px, ${currentTranslateY}px) scale(${currentScale})`;
        mediaEl.style.transformOrigin = "center center";
        mediaEl.style.transition = "none";
      }

      function resetMediaTransform() {
        currentScale = 1;
        currentTranslateX = 0;
        currentTranslateY = 0;
        const item = track.querySelector('[data-offset="0"]');
        if (item) {
          const mediaEl = item.querySelector(".swipe-media");
          if (mediaEl) {
            mediaEl.style.transform = "";
            mediaEl.style.transformOrigin = "";
            mediaEl.style.transition = "";
          }
        }
      }

      // Touch handlers
      let touchStartX = 0;

      function onTouchStart(e) {
        // Ignore touches on UI elements
        if (
          e.target.closest(".swipe-actions") ||
          e.target.closest(".swipe-header") ||
          e.target.closest(".filter-modal") ||
          e.target.closest(".install-prompt")
        )
          return;

        // Handle scrubber touches separately
        if (e.target.closest(".scrubber-track")) {
          handleScrubStart(e);
          return;
        }

        // Don't start swipe if touching scrubber area
        if (e.target.closest(".video-scrubber")) {
          return;
        }

        // Multi-touch for pan and zoom
        if (e.touches.length === 2) {
          e.preventDefault();
          isMultiTouch = true;
          isDragging = false;
          track.classList.remove("dragging");

          const touch1 = e.touches[0];
          const touch2 = e.touches[1];

          initialDistance = getTouchDistance(touch1, touch2);
          initialScale = currentScale;

          const center = getTouchCenter(touch1, touch2);
          initialTouchCenter = center;
          lastTouchCenter = center;

          return;
        }

        // Single touch - only start dragging if not already multi-touch
        if (e.touches.length === 1 && !isMultiTouch) {
          touchStartY = e.touches[0].clientY;
          touchStartX = e.touches[0].clientX;
          touchCurrentY = touchStartY;
          touchStartTime = Date.now();
          lastTouchY = touchStartY;
          lastTouchTime = touchStartTime;
          velocityY = 0;
          isDragging = true;
          track.classList.add("dragging");

          // Add dragging class to items for instant response
          const itemEls = track.querySelectorAll(".swipe-item");
          itemEls.forEach((el) => el.classList.add("dragging"));

          // Check for double tap
          const now = Date.now();
          if (now - lastTapTime < 300) {
            // If zoomed in, reset zoom on double tap
            if (currentScale > 1) {
              resetMediaTransform();
            } else {
              toggleLike();
            }
            isDragging = false;
            track.classList.remove("dragging");
            itemEls.forEach((el) => el.classList.remove("dragging"));
          }
          lastTapTime = now;
        }
      }

      function onTouchMove(e) {
        // Handle scrubber dragging
        if (isScrubbing) {
          handleScrubMove(e);
          return;
        }

        // Handle multi-touch pan and zoom
        if (isMultiTouch && e.touches.length === 2) {
          e.preventDefault();

          const item = track.querySelector('[data-offset="0"]');
          if (!item) return;
          const mediaEl = item.querySelector(".swipe-media");
          if (!mediaEl) return;

          const touch1 = e.touches[0];
          const touch2 = e.touches[1];

          // Pinch to zoom
          const currentDistance = getTouchDistance(touch1, touch2);
          const scaleChange = currentDistance / initialDistance;
          currentScale = Math.max(1, Math.min(5, initialScale * scaleChange)); // Clamp between 1x and 5x

          // Two-finger pan
          const currentCenter = getTouchCenter(touch1, touch2);
          const deltaX = currentCenter.x - lastTouchCenter.x;
          const deltaY = currentCenter.y - lastTouchCenter.y;

          currentTranslateX += deltaX;
          currentTranslateY += deltaY;

          // Constrain panning based on scale
          // Allow more panning when zoomed in
          const maxTranslate = 200 * currentScale;
          currentTranslateX = Math.max(
            -maxTranslate,
            Math.min(maxTranslate, currentTranslateX)
          );
          currentTranslateY = Math.max(
            -maxTranslate,
            Math.min(maxTranslate, currentTranslateY)
          );

          lastTouchCenter = currentCenter;

          applyMediaTransform(mediaEl);
          return;
        }

        if (!isDragging) return;
        e.preventDefault();

        const currentY = e.touches[0].clientY;
        const currentTime = Date.now();

        // Calculate velocity for momentum
        const timeDelta = currentTime - lastTouchTime;
        if (timeDelta > 0) {
          velocityY = (currentY - lastTouchY) / timeDelta;
        }
        lastTouchY = currentY;
        lastTouchTime = currentTime;

        touchCurrentY = currentY;
        const deltaY = touchCurrentY - touchStartY;
        const height = container.clientHeight;

        // Calculate raw drag percentage
        let dragPercent = (deltaY / height) * 100;

        // Apply rubber-banding at edges
        const atTop = currentIndex === 0 && deltaY > 0;
        const atBottom = currentIndex === items.length - 1 && deltaY < 0;

        if (atTop || atBottom) {
          // Apply resistance curve - the further you drag, the more resistance
          const resistance = 0.4;
          dragPercent = dragPercent * resistance;
        }

        // Move all items with depth effects
        const itemEls = track.querySelectorAll(".swipe-item");
        itemEls.forEach((el) => {
          const baseOffset = parseInt(el.dataset.offset);
          const translateY = baseOffset * 100 + dragPercent;

          // Calculate interpolation factor (how far are we dragging)
          const dragProgress = Math.abs(dragPercent) / 100;

          // Apply scale, opacity, and filter transitions for depth
          let scale, opacity, translateZ, brightness, blur;

          if (baseOffset === 0) {
            // Current item shrinks and fades as we drag
            scale = 1 - dragProgress * 0.1;
            opacity = 1 - dragProgress * 0.4;
            translateZ = -dragProgress * 100;
            brightness = 1 - dragProgress * 0.2;
            blur = dragProgress * 1;
          } else if (
            (baseOffset === 1 && deltaY < 0) ||
            (baseOffset === -1 && deltaY > 0)
          ) {
            // Next item scales up and brightens as it comes into view
            const progress = Math.min(dragProgress, 1);
            scale = 0.9 + progress * 0.1;
            opacity = 0.6 + progress * 0.4;
            translateZ = -100 + progress * 100;
            brightness = (baseOffset === 1 ? 0.65 : 0.8) + progress * (1 - (baseOffset === 1 ? 0.65 : 0.8));
            blur = (baseOffset === 1 ? 1 : 0.5) * (1 - progress);
          } else {
            // Other items maintain their state
            scale = 0.9;
            opacity = 0.6;
            translateZ = -100;
            brightness = baseOffset === 1 ? 0.65 : 0.8;
            blur = baseOffset === 1 ? 1 : 0.5;
          }

          el.style.transform = `translateY(${translateY}%) scale(${scale}) translateZ(${translateZ}px)`;
          el.style.opacity = opacity;
          el.style.filter = `brightness(${brightness}) blur(${blur}px)`;
        });
      }

      function onTouchEnd(e) {
        // Handle scrubber end
        if (isScrubbing) {
          handleScrubEnd(e);
          return;
        }

        // Handle multi-touch end
        if (isMultiTouch) {
          // If we still have touches remaining, update multi-touch state
          if (e.touches.length >= 2) {
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            initialDistance = getTouchDistance(touch1, touch2);
            initialScale = currentScale;
            const center = getTouchCenter(touch1, touch2);
            initialTouchCenter = center;
            lastTouchCenter = center;
          } else {
            // Multi-touch ended, reset flag
            isMultiTouch = false;
          }
          return;
        }

        if (!isDragging) return;

        isDragging = false;
        track.classList.remove("dragging");

        const deltaY = touchCurrentY - touchStartY;
        const deltaX = e.changedTouches
          ? e.changedTouches[0].clientX - touchStartX
          : 0;
        const height = container.clientHeight;

        // Calculate velocity-based threshold
        // High velocity = easier to trigger swipe
        const velocityThreshold = 0.5; // pixels per ms
        const distanceThreshold = height * 0.12; // 12% of screen height

        const hasVelocity = Math.abs(velocityY) > velocityThreshold;
        const hasDistance = Math.abs(deltaY) > distanceThreshold;

        // Determine if we should change items
        const shouldGoNext =
          (hasVelocity && velocityY < -velocityThreshold) ||
          (hasDistance && deltaY < -distanceThreshold);
        const shouldGoPrev =
          (hasVelocity && velocityY > velocityThreshold) ||
          (hasDistance && deltaY > distanceThreshold);

        // Remove dragging class from items
        const itemEls = track.querySelectorAll(".swipe-item");
        itemEls.forEach((el) => el.classList.remove("dragging"));

        if (shouldGoNext && currentIndex < items.length - 1) {
          // Swiped up with velocity or distance - go to next
          track.classList.add("transitioning");
          setTimeout(() => track.classList.remove("transitioning"), 450);
          goNext();
        } else if (shouldGoPrev && currentIndex > 0) {
          // Swiped down with velocity or distance - go to previous
          track.classList.add("transitioning");
          setTimeout(() => track.classList.remove("transitioning"), 450);
          goPrev();
        } else {
          // Snap back with bounce effect
          track.classList.add("snapping");
          setTimeout(() => track.classList.remove("snapping"), 400);

          itemEls.forEach((el) => {
            const baseOffset = parseInt(el.dataset.offset);
            const scale = baseOffset === 0 ? 1 : 0.9;
            const opacity = baseOffset === 0 ? 1 : 0.6;
            const translateY = baseOffset * 100;
            const translateZ = baseOffset === 0 ? 0 : -100;
            const brightness = baseOffset === 0 ? 1 : (baseOffset === 1 ? 0.65 : 0.8);
            const blur = baseOffset === 0 ? 0 : (baseOffset === 1 ? 1 : 0.5);

            el.style.transform = `translateY(${translateY}%) scale(${scale}) translateZ(${translateZ}px)`;
            el.style.opacity = opacity;
            el.style.filter = `brightness(${brightness}) blur(${blur}px)`;
          });

          // Check for tap on video (small movement)
          if (Math.abs(deltaY) < 10 && Math.abs(deltaX) < 10) {
            const item = track.querySelector('[data-offset="0"]');
            const video = item?.querySelector("video");
            if (video) {
              // Toggle scrubber visibility on tap, or toggle pause if scrubber visible
              if (scrubberVisible) {
                toggleVideoPause();
              } else {
                showScrubber();
                // Reset auto-hide timer
                clearTimeout(scrubberHideTimeout);
                if (!video.paused) {
                  scrubberHideTimeout = setTimeout(hideScrubber, 3000);
                }
              }
            }
          }
        }
      }

      // Keyboard navigation
      function onKeyDown(e) {
        // Check if filter modal is open
        if (filterModal.classList.contains("show")) {
          if (e.key === "Escape") {
            filterModal.classList.remove("show");
          }
          return; // Don't handle other keys when modal is open
        }

        switch (e.key) {
          case "ArrowUp":
          case "ArrowLeft":
            e.preventDefault();
            goPrev();
            break;
          case "ArrowDown":
          case "ArrowRight":
          case " ":
            e.preventDefault();
            goNext();
            break;
          case "l":
            toggleLike();
            break;
          case "f":
            toggleFitMode();
            break;
        }
      }

      // Tag filtering functions
      async function loadAllTags() {
        try {
          const response = await fetch("/media/suggest?kind=tag&prefix=");
          const data = await response.json();
          // New format: { tags: [{label: "...", category: "..."}] }
          allTags = (data.tags || []).map((tag) => ({
            label: tag.label,
            category: tag.category,
          }));
          filteredTags = [...allTags];
          renderTagList();
        } catch (err) {
          console.error("Failed to load tags:", err);
          tagList.innerHTML =
            '<div class="tag-list-empty">Failed to load tags</div>';
        }
      }

      function renderSelectedTags() {
        if (selectedTags.size === 0) {
          selectedTagsContainer.innerHTML = "";
          return;
        }

        const chips = Array.from(selectedTags)
          .map(
            (tag) =>
              `<div class="selected-tag-chip">
              <span>${escapeHtml(tag)}</span>
              <button type="button" onclick="removeTag('${escapeAttr(
                tag
              )}')">‚úï</button>
            </div>`
          )
          .join("");

        const clearAll =
          selectedTags.size > 1
            ? '<div class="clear-all-tags" onclick="clearAllTags()">Clear all</div>'
            : "";

        selectedTagsContainer.innerHTML = chips + clearAll;
      }

      function renderTagList() {
        if (filteredTags.length === 0) {
          tagList.innerHTML =
            '<div class="tag-list-empty">No tags found</div>';
          return;
        }

        // Group tags by category
        const tagsByCategory = {};
        filteredTags.forEach((tag) => {
          const category = tag.category || "Other";
          if (!tagsByCategory[category]) {
            tagsByCategory[category] = [];
          }
          tagsByCategory[category].push(tag);
        });

        // Sort categories alphabetically
        const categories = Object.keys(tagsByCategory).sort();

        // Render grouped tags with proper section structure
        let html = "";
        categories.forEach((category) => {
          html += `<div class="tag-category-section">
            <div class="tag-category-header">${escapeHtml(category)}</div>
            <div class="tag-category-items">`;

          tagsByCategory[category].forEach((tag) => {
            const selected = selectedTags.has(tag.label) ? "selected" : "";
            html += `<div class="tag-item ${selected}" onclick="toggleTag('${escapeAttr(
              tag.label
            )}')">
              <span>${escapeHtml(tag.label)}</span>
            </div>`;
          });

          html += `</div></div>`;
        });

        tagList.innerHTML = html;
      }

      function toggleTag(tag) {
        if (selectedTags.has(tag)) {
          selectedTags.delete(tag);
        } else {
          selectedTags.add(tag);
        }
        saveSelectedTags();
        renderSelectedTags();
        renderTagList();
      }

      function removeTag(tag) {
        selectedTags.delete(tag);
        saveSelectedTags();
        renderSelectedTags();
        renderTagList();
      }

      function clearAllTags() {
        selectedTags.clear();
        saveSelectedTags();
        renderSelectedTags();
        renderTagList();
      }

      function filterTagList(searchTerm) {
        const term = searchTerm.toLowerCase().trim();
        if (!term) {
          filteredTags = [...allTags];
        } else {
          filteredTags = allTags.filter(
            (tag) =>
              tag.label.toLowerCase().includes(term) ||
              (tag.category && tag.category.toLowerCase().includes(term))
          );
        }
        renderTagList();
      }

      // Filter modal
      document.getElementById("filterBtn").addEventListener("click", () => {
        filterModal.classList.add("show");
        tagSearch.value = ""; // Clear search input
        loadAllTags();
        renderSelectedTags();
        // Don't auto-focus search to avoid keyboard pop-up on mobile
      });

      document.getElementById("filterClose").addEventListener("click", () => {
        filterModal.classList.remove("show");
      });

      tagSearch.addEventListener("input", (e) => {
        filterTagList(e.target.value);
      });

      tagSearch.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          applyFilter();
        } else if (e.key === "Escape") {
          filterModal.classList.remove("show");
        }
      });

      function applyFilter() {
        const newQuery = buildTagQuery();
        saveSelectedTags();
        if (newQuery !== searchQuery) {
          searchQuery = newQuery;
          items = [];
          currentIndex = 0;
          hasMore = true;
          // Generate new session seed for the new filter
          sessionSeed = Date.now().toString();
          sessionStorage.setItem(SESSION_SEED_KEY, sessionSeed);
          init();
        }
        filterModal.classList.remove("show");
      }

      document
        .getElementById("filterApply")
        .addEventListener("click", applyFilter);

      // Make functions global for onclick handlers
      window.toggleTag = toggleTag;
      window.removeTag = removeTag;
      window.clearAllTags = clearAllTags;

      // Action buttons
      likeBtn.addEventListener("click", toggleLike);
      openBtn.addEventListener("click", openInBrowser);
      fitBtn.addEventListener("click", toggleFitMode);

      // Utility functions
      function isVideoFile(path) {
        const ext = path.split(".").pop().toLowerCase();
        return [
          "mp4",
          "webm",
          "ogg",
          "avi",
          "mov",
          "wmv",
          "flv",
          "mkv",
          "m4v",
        ].includes(ext);
      }

      function getMediaUrl(path) {
        if (path.startsWith("http://") || path.startsWith("https://")) {
          return path;
        }
        return `/media/file?path=${encodeURIComponent(path)}`;
      }

      function getFileName(path) {
        return path.split(/[/\\]/).pop();
      }

      function escapeHtml(text) {
        if (!text) return "";
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function escapeAttr(text) {
        if (!text) return "";
        return String(text)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }


      // Event listeners
      container.addEventListener("touchstart", onTouchStart, {
        passive: false,
      });
      container.addEventListener("touchmove", onTouchMove, { passive: false });
      container.addEventListener("touchend", onTouchEnd);
      document.addEventListener("keydown", onKeyDown);

      // Mouse support for scrubber (desktop)
      container.addEventListener("mousedown", (e) => {
        if (e.target.closest(".scrubber-track")) {
          handleScrubStart(e);
        }
      });
      document.addEventListener("mousemove", (e) => {
        if (isScrubbing) {
          handleScrubMove(e);
        }
      });
      document.addEventListener("mouseup", (e) => {
        if (isScrubbing) {
          handleScrubEnd(e);
        }
      });

      // Click on video to toggle scrubber (desktop)
      container.addEventListener("click", (e) => {
        if (
          e.target.closest(".swipe-actions") ||
          e.target.closest(".swipe-header") ||
          e.target.closest(".filter-modal") ||
          e.target.closest(".video-scrubber") ||
          e.target.closest(".install-prompt")
        ) {
          return;
        }

        const item = track.querySelector('[data-offset="0"]');
        const video = item?.querySelector("video");
        if (video) {
          if (scrubberVisible) {
            toggleVideoPause();
          } else {
            showScrubber();
            clearTimeout(scrubberHideTimeout);
            if (!video.paused) {
              scrubberHideTimeout = setTimeout(hideScrubber, 3000);
            }
          }
        }
      });

      // Mouse wheel support for desktop
      let wheelTimeout;
      container.addEventListener(
        "wheel",
        (e) => {
          if (e.target.closest(".filter-modal")) return;
          e.preventDefault();

          clearTimeout(wheelTimeout);
          wheelTimeout = setTimeout(() => {
            if (e.deltaY > 0) {
              goNext();
            } else {
              goPrev();
            }
          }, 50);
        },
        { passive: false }
      );

      // Start
      init();
    </script>
  </body>
</html>
{{ end }}
