{{ define "home" }}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shrike ‚Äì Quick Jobs</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      /* Active Jobs Panel */
      .active-jobs-panel {
        background: linear-gradient(
          145deg,
          var(--bg-elevated) 0%,
          var(--bg-surface) 100%
        );
        border: 1px solid var(--border-subtle);
        border-radius: var(--radius-xl);
        padding: var(--space-5);
        margin-bottom: var(--space-6);
        box-shadow: var(--shadow-md);
      }

      .active-jobs-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--space-4);
      }

      .active-jobs-header h2 {
        margin: 0;
        font-size: var(--text-sm);
        font-weight: 600;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: var(--space-3);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .active-jobs-header .pulse-dot {
        width: 8px;
        height: 8px;
        border-radius: var(--radius-full);
        background: var(--status-success);
        animation: pulse 2s ease-in-out infinite;
        box-shadow: 0 0 8px var(--status-success);
      }

      .active-jobs-header .pulse-dot.idle {
        background: var(--text-muted);
        box-shadow: none;
        animation: none;
      }

      .jobs-count {
        font-size: var(--text-xs);
        color: var(--text-secondary);
        background: var(--bg-active);
        padding: var(--space-1) var(--space-3);
        border-radius: var(--radius-full);
        font-weight: 500;
      }

      .active-jobs-list {
        display: flex;
        flex-direction: column;
        gap: var(--space-2);
        max-height: 220px;
        overflow-y: auto;
      }

      .active-jobs-empty {
        text-align: center;
        color: var(--text-muted);
        font-size: var(--text-sm);
        padding: var(--space-6);
        background: var(--bg-surface);
        border-radius: var(--radius-lg);
        border: 1px dashed var(--border-default);
      }

      a.job-item,
      .job-item {
        display: flex;
        align-items: center;
        gap: var(--space-3);
        padding: var(--space-3) var(--space-4);
        background: var(--bg-surface);
        border-radius: var(--radius-lg);
        border-left: 3px solid transparent;
        transition: all var(--transition-fast);
        text-decoration: none;
        cursor: pointer;
        color: inherit;
      }

      .job-item:hover {
        background: var(--bg-hover);
      }

      .job-item.running {
        border-left-color: var(--accent-cyan);
        background: var(--accent-cyan-dim);
      }

      .job-item.pending {
        border-left-color: var(--status-pending);
        background: var(--status-pending-dim);
      }

      .job-status-indicator {
        width: 12px;
        height: 12px;
        border-radius: var(--radius-full);
        flex-shrink: 0;
      }

      .job-status-indicator.running {
        background-color: transparent;
        border: 2px solid var(--accent-cyan);
        border-top-color: transparent;
        animation: spin 1s linear infinite;
      }

      .job-status-indicator.pending {
        background-color: var(--status-pending);
        opacity: 0.8;
      }

      .job-info {
        flex: 1;
        min-width: 0;
      }

      .job-command {
        font-family: var(--font-mono);
        font-size: var(--text-sm);
        color: var(--accent-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-weight: 500;
      }

      .job-detail {
        font-size: var(--text-xs);
        color: var(--text-muted);
        margin-top: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .job-actions {
        display: flex;
        gap: var(--space-2);
        align-items: center;
      }

      .job-link-icon {
        color: var(--text-muted);
        font-size: var(--text-sm);
        opacity: 0;
        transition: opacity var(--transition-fast);
      }

      .job-item:hover .job-link-icon {
        opacity: 1;
      }

      .job-actions button {
        font-size: var(--text-xs);
        padding: var(--space-1) var(--space-2);
        background: var(--bg-hover);
        border: 1px solid var(--border-default);
        color: var(--text-secondary);
        border-radius: var(--radius-sm);
        cursor: pointer;
        transition: all var(--transition-fast);
        font-weight: 500;
      }

      .job-actions button:hover {
        background: var(--status-error-dim);
        color: var(--status-error);
        border-color: rgba(239, 68, 68, 0.3);
      }

      /* Card Grid */
      .card-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(280px, 1fr));
        gap: var(--space-5);
      }

      .task-card {
        background: var(--bg-card);
        border: 1px solid var(--border-subtle);
        border-radius: var(--radius-xl);
        padding: var(--space-5);
        position: relative;
        transition: all var(--transition-base);
        overflow: hidden;
      }

      .task-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(
          90deg,
          var(--card-accent, var(--accent-primary)),
          transparent
        );
        opacity: 0.7;
      }

      .task-card:hover {
        border-color: var(--border-default);
      }

      /* Card accent colors */
      .task-card--ingest {
        --card-accent: var(--status-success);
      }
      .task-card--transcript {
        --card-accent: var(--accent-purple);
      }
      .task-card--description {
        --card-accent: var(--status-pending);
      }
      .task-card--autotag {
        --card-accent: var(--accent-blue);
      }
      .task-card--cleanup {
        --card-accent: var(--status-error);
      }

      /* Card Status Badge */
      .card-status {
        position: absolute;
        top: var(--space-4);
        right: var(--space-4);
        display: flex;
        align-items: center;
        gap: var(--space-2);
        font-size: var(--text-xs);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        padding: var(--space-1) var(--space-3);
        border-radius: var(--radius-full);
        opacity: 0;
        transform: translateY(-4px);
        transition: all var(--transition-slow);
      }

      .card-status.visible {
        opacity: 1;
        transform: translateY(0);
      }

      .card-status.running {
        background: var(--accent-cyan-dim);
        color: var(--accent-cyan);
        border: 1px solid rgba(97, 218, 251, 0.35);
      }

      .card-status.pending {
        background: var(--status-pending-dim);
        color: var(--status-pending);
        border: 1px solid rgba(245, 158, 11, 0.35);
      }

      .card-status .status-dot {
        width: 6px;
        height: 6px;
        border-radius: var(--radius-full);
      }

      .card-status.running .status-dot {
        background: transparent;
        border: 1.5px solid var(--accent-cyan);
        border-top-color: transparent;
        animation: spin 0.8s linear infinite;
      }

      .card-status.pending .status-dot {
        background: var(--status-pending);
      }

      .task-card .card-header {
        display: flex;
        align-items: flex-start;
        gap: var(--space-3);
        margin-bottom: var(--space-3);
      }

      .task-card .card-icon {
        width: 44px;
        height: 44px;
        border-radius: var(--radius-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        flex-shrink: 0;
        background: linear-gradient(
          135deg,
          var(--card-accent, var(--accent-primary)),
          transparent
        );
        opacity: 0.9;
      }

      .task-card h3 {
        margin: 0;
        font-size: var(--text-base);
        font-weight: 600;
        color: var(--text-primary);
        line-height: 1.3;
      }

      .task-card .card-description {
        color: var(--text-secondary);
        margin: var(--space-1) 0 0 0;
        font-size: var(--text-sm);
        line-height: 1.45;
      }

      .task-card .card-body {
        margin-top: var(--space-4);
      }

      /* Buttons */
      .task-card .btn {
        padding: var(--space-3) var(--space-4);
        border-radius: var(--radius-lg);
        cursor: pointer;
        border: 1px solid var(--border-default);
        background: var(--bg-hover);
        color: var(--text-primary);
        font-weight: 600;
        font-size: var(--text-sm);
        transition: all var(--transition-fast);
      }

      .task-card .btn:hover {
        background: var(--bg-active);
        border-color: var(--border-strong);
      }

      .task-card .btn-primary {
        background: linear-gradient(
          135deg,
          var(--card-accent, var(--accent-primary)) 0%,
          color-mix(
              in srgb,
              var(--card-accent, var(--accent-primary)) 70%,
              #000
            )
            100%
        );
        color: #000;
        border-color: transparent;
        font-weight: 700;
      }

      .task-card .btn-primary:hover {
        filter: brightness(1.1);
      }

      .task-card .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Form Elements */
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-3);
        align-items: center;
      }

      .task-card .input {
        width: 100%;
        padding: var(--space-3);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border-default);
        background-color: var(--bg-surface);
        color: var(--text-primary);
        font-family: var(--font-mono);
        font-size: var(--text-sm);
        box-sizing: border-box;
        transition: all var(--transition-fast);
      }

      .task-card .input:focus {
        outline: none;
        border-color: var(--card-accent, var(--accent-primary));
        box-shadow: 0 0 0 3px rgba(0, 212, 170, 0.15);
      }

      .task-card .input::placeholder {
        color: var(--text-muted);
      }

      .task-card label {
        color: var(--text-secondary);
        font-size: var(--text-sm);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
      }

      .task-card label input[type="checkbox"] {
        margin-right: var(--space-2);
        accent-color: var(--card-accent, var(--accent-primary));
      }

      /* Status Messages */
      .status-message {
        font-size: var(--text-sm);
        padding: var(--space-3);
        border-radius: var(--radius-lg);
        margin-top: var(--space-3);
        display: none;
        animation: slideIn 0.2s ease;
      }

      .status-message.success {
        background: var(--status-success-dim);
        color: var(--status-success);
        border: 1px solid rgba(34, 197, 94, 0.25);
      }

      .status-message.error {
        background: var(--status-error-dim);
        color: var(--status-error);
        border: 1px solid rgba(239, 68, 68, 0.25);
      }

      .status-message.info {
        background: var(--accent-cyan-dim);
        color: var(--accent-cyan);
        border: 1px solid rgba(97, 218, 251, 0.25);
      }

      /* Footer Link */
      .footer-link {
        margin-top: var(--space-6);
        padding: var(--space-4) var(--space-5);
        background: var(--bg-surface);
        border-radius: var(--radius-lg);
        border: 1px dashed var(--border-default);
        text-align: center;
      }

      .footer-link a {
        color: var(--accent-primary);
        text-decoration: none;
        font-weight: 500;
        transition: color var(--transition-fast);
      }

      .footer-link a:hover {
        color: var(--text-primary);
      }

      @media screen and (max-width: 800px) {
        .card-grid {
          grid-template-columns: 1fr;
        }

        .active-jobs-panel {
          margin-bottom: var(--space-4);
        }

        .task-card {
          padding: var(--space-4);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      {{ template "topnav" . }}

      <!-- Active Jobs Panel -->
      <div class="active-jobs-panel">
        <div class="active-jobs-header">
          <h2>
            <span class="pulse-dot idle" id="activityIndicator"></span>
            Active Jobs
          </h2>
          <div style="display: flex; align-items: center; gap: var(--space-3)">
            <span class="jobs-count" id="jobsCount">0 jobs</span>
            <div class="connection-status" id="connectionStatus">
              <span class="dot"></span>
              <span>Connected</span>
            </div>
          </div>
        </div>
        <div class="active-jobs-list" id="activeJobsList">
          <div class="active-jobs-empty" id="emptyState">
            No active jobs ‚Äî start one below!
          </div>
        </div>
      </div>

      <div class="card-grid">
        <!-- Ingest Card -->
        <div class="task-card task-card--ingest" id="card-ingest">
          <div class="card-status" id="status-ingest">
            <span class="status-dot"></span>
            <span class="status-text">Running</span>
          </div>
          <div class="card-header">
            <div class="card-icon">üì•</div>
            <div class="card-titles">
              <h3>Ingest Media</h3>
              <p class="card-description">
                Scan a folder and import new media files
              </p>
            </div>
          </div>
          <div class="card-body">
            <div class="row" style="margin-bottom: var(--space-3)">
              <input
                class="input"
                id="ingestPath"
                name="ingestPath"
                list="pathdir-suggestions"
                placeholder="e.g. C:\Media\New"
              />
              <datalist id="pathdir-suggestions"></datalist>
            </div>
            <div class="row" style="margin-bottom: var(--space-4)">
              <label for="ingestRecursive">
                <input type="checkbox" id="ingestRecursive" />
                Scan recursively
              </label>
            </div>
            <div class="row">
              <button class="btn btn-primary" onclick="createIngestJob()">
                Start Ingest
              </button>
            </div>
            <div id="ingestStatus" class="status-message"></div>
          </div>
        </div>

        <!-- Transcripts Card -->
        <div class="task-card task-card--transcript" id="card-transcript">
          <div class="card-status" id="status-transcript">
            <span class="status-dot"></span>
            <span class="status-text">Running</span>
          </div>
          <div class="card-header">
            <div class="card-icon">üéôÔ∏è</div>
            <div class="card-titles">
              <h3>Generate Transcripts</h3>
              <p class="card-description">
                Transcribe audio/video files using Whisper
              </p>
            </div>
          </div>
          <div class="card-body">
            <button class="btn btn-primary" onclick="createTranscriptsJob()">
              Start Transcripts Job
            </button>
            <div id="transcriptStatus" class="status-message"></div>
          </div>
        </div>

        <!-- Descriptions Card -->
        <div class="task-card task-card--description" id="card-description">
          <div class="card-status" id="status-description">
            <span class="status-dot"></span>
            <span class="status-text">Running</span>
          </div>
          <div class="card-header">
            <div class="card-icon">‚ú®</div>
            <div class="card-titles">
              <h3>Generate Descriptions</h3>
              <p class="card-description">
                Create AI-powered descriptions for media
              </p>
            </div>
          </div>
          <div class="card-body">
            <button class="btn btn-primary" onclick="createDescriptionsJob()">
              Start Descriptions Job
            </button>
            <div id="descriptionStatus" class="status-message"></div>
          </div>
        </div>

        <!-- Autotag Card -->
        <div class="task-card task-card--autotag" id="card-autotag">
          <div class="card-status" id="status-autotag">
            <span class="status-dot"></span>
            <span class="status-text">Running</span>
          </div>
          <div class="card-header">
            <div class="card-icon">üè∑Ô∏è</div>
            <div class="card-titles">
              <h3>Auto-Tag with ONNX</h3>
              <p class="card-description">
                Automatically tag images using ML vision model
              </p>
            </div>
          </div>
          <div class="card-body">
            <button class="btn btn-primary" onclick="createOnnxAutotagJob()">
              Start Auto-Tag Job
            </button>
            <div id="autotagStatus" class="status-message"></div>
          </div>
        </div>

        <!-- Cleanup Card -->
        <div class="task-card task-card--cleanup" id="card-cleanup">
          <div class="card-status" id="status-cleanup">
            <span class="status-dot"></span>
            <span class="status-text">Running</span>
          </div>
          <div class="card-header">
            <div class="card-icon">üßπ</div>
            <div class="card-titles">
              <h3>Cleanup Database</h3>
              <p class="card-description">
                Remove entries for missing files from disk
              </p>
            </div>
          </div>
          <div class="card-body">
            <button class="btn btn-primary" onclick="createCleanupJob()">
              Start Cleanup
            </button>
            <div id="cleanupStatus" class="status-message"></div>
          </div>
        </div>
      </div>

      <div class="footer-link">
        View detailed job progress in <a href="/jobs">Jobs Dashboard ‚Üí</a>
      </div>
    </div>

    <script>
      // Job state tracking
      const jobsState = {
        jobs: new Map(),
        cardTypes: {
          ingest: "ingest",
          metadata: null,
          autotag: "autotag",
          cleanup: "cleanup",
        },
      };

      function b64(s) {
        return btoa(unescape(encodeURIComponent(s)));
      }

      function postCreate(input) {
        return fetch("/create", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input }),
        }).then((r) => {
          if (!r.ok) throw new Error("request failed");
          return r.json();
        });
      }

      function showStatus(elementId, message, type) {
        const el = document.getElementById(elementId);
        if (!el) return;
        el.className = "status-message " + type;
        el.textContent = message;
        el.style.display = "block";
        if (type === "success") {
          setTimeout(() => {
            el.style.display = "none";
          }, 5000);
        }
      }

      function createTranscriptsJob() {
        const query = 'transcript:""';
        const args = "--type transcript --apply all --query64=" + b64(query);
        postCreate(`metadata ${args}`)
          .then((res) => {
            showStatus("transcriptStatus", "Job created: " + res.id, "success");
          })
          .catch((err) =>
            showStatus("transcriptStatus", "Error: " + err.message, "error")
          );
      }

      function createDescriptionsJob() {
        const query = 'description:""';
        const args = "--type description --apply all --query64=" + b64(query);
        postCreate(`metadata ${args}`)
          .then((res) => {
            showStatus(
              "descriptionStatus",
              "Job created: " + res.id,
              "success"
            );
          })
          .catch((err) =>
            showStatus("descriptionStatus", "Error: " + err.message, "error")
          );
      }

      function createOnnxAutotagJob() {
        const query = "tags:none";
        const args = "--query64=" + b64(query);
        postCreate(`autotag ${args}`)
          .then((res) => {
            showStatus("autotagStatus", "Job created: " + res.id, "success");
          })
          .catch((err) =>
            showStatus("autotagStatus", "Error: " + err.message, "error")
          );
      }

      function createIngestJob() {
        const path = (document.getElementById("ingestPath").value || "").trim();
        const recursive = document.getElementById("ingestRecursive").checked;
        if (!path) {
          showStatus("ingestStatus", "Please enter a folder path.", "error");
          return;
        }
        showStatus("ingestStatus", "Creating ingest job...", "info");
        const args = (recursive ? "--recursive " : "") + `"${path}"`;
        postCreate(`ingest ${args}`)
          .then((res) => {
            showStatus("ingestStatus", "Job created: " + res.id, "success");
            document.getElementById("ingestPath").value = "";
          })
          .catch((err) =>
            showStatus("ingestStatus", "Error: " + err.message, "error")
          );
      }

      function createCleanupJob() {
        postCreate("cleanup")
          .then((res) => {
            showStatus("cleanupStatus", "Job created: " + res.id, "success");
          })
          .catch((err) =>
            showStatus("cleanupStatus", "Error: " + err.message, "error")
          );
      }

      function getCardTypeFromJob(job) {
        const cmd = (job.command || job.Command || "").toLowerCase();
        const args = (job.arguments || job.Arguments || "").toLowerCase();

        if (cmd === "ingest") return "ingest";
        if (cmd === "autotag") return "autotag";
        if (cmd === "cleanup") return "cleanup";
        if (cmd === "metadata") {
          if (args.includes("--type transcript")) return "transcript";
          if (args.includes("--type description")) return "description";
        }
        return null;
      }

      function getJobState(job) {
        const state = job.state || job.State;
        if (state === 0 || state === "Pending") return "pending";
        if (state === 1 || state === "InProgress") return "running";
        return null;
      }

      function updateCardStatuses() {
        const cardStatuses = {
          ingest: { running: 0, pending: 0 },
          transcript: { running: 0, pending: 0 },
          description: { running: 0, pending: 0 },
          autotag: { running: 0, pending: 0 },
          cleanup: { running: 0, pending: 0 },
        };

        jobsState.jobs.forEach((job) => {
          const cardType = getCardTypeFromJob(job);
          const state = getJobState(job);
          if (cardType && state && cardStatuses[cardType]) {
            cardStatuses[cardType][state]++;
          }
        });

        Object.keys(cardStatuses).forEach((type) => {
          const statusEl = document.getElementById("status-" + type);
          if (!statusEl) return;

          const { running, pending } = cardStatuses[type];
          if (running > 0) {
            statusEl.className = "card-status running visible";
            statusEl.querySelector(".status-text").textContent =
              running > 1 ? `${running} Running` : "Running";
          } else if (pending > 0) {
            statusEl.className = "card-status pending visible";
            statusEl.querySelector(".status-text").textContent =
              pending > 1 ? `${pending} Queued` : "Queued";
          } else {
            statusEl.className = "card-status";
          }
        });
      }

      function renderActiveJobsList() {
        const listEl = document.getElementById("activeJobsList");
        const emptyEl = document.getElementById("emptyState");
        const countEl = document.getElementById("jobsCount");
        const activityEl = document.getElementById("activityIndicator");

        const activeJobs = Array.from(jobsState.jobs.values()).filter((job) => {
          const state = getJobState(job);
          return state === "pending" || state === "running";
        });

        activeJobs.sort((a, b) => {
          const stateA = getJobState(a);
          const stateB = getJobState(b);
          if (stateA === "running" && stateB !== "running") return -1;
          if (stateA !== "running" && stateB === "running") return 1;
          return 0;
        });

        const runningCount = activeJobs.filter(
          (j) => getJobState(j) === "running"
        ).length;
        const pendingCount = activeJobs.filter(
          (j) => getJobState(j) === "pending"
        ).length;

        let countText = "";
        if (runningCount > 0 && pendingCount > 0) {
          countText = `${runningCount} running, ${pendingCount} queued`;
        } else if (runningCount > 0) {
          countText = `${runningCount} running`;
        } else if (pendingCount > 0) {
          countText = `${pendingCount} queued`;
        } else {
          countText = "0 jobs";
        }
        countEl.textContent = countText;

        if (runningCount > 0) {
          activityEl.classList.remove("idle");
        } else {
          activityEl.classList.add("idle");
        }

        if (activeJobs.length === 0) {
          emptyEl.style.display = "block";
          listEl.querySelectorAll(".job-item").forEach((el) => el.remove());
          return;
        }

        emptyEl.style.display = "none";

        const existingIds = new Set();
        activeJobs.forEach((job) => {
          const jobId = job.id || job.ID;
          existingIds.add(jobId);

          let itemEl = listEl.querySelector(`[data-job-id="${jobId}"]`);
          const state = getJobState(job);
          const command = job.command || job.Command || "";
          const args = job.arguments || job.Arguments || "";
          const input = job.input || job.Input || "";

          if (!itemEl) {
            itemEl = document.createElement("a");
            itemEl.href = `/job/${jobId}`;
            itemEl.className = "job-item " + state;
            itemEl.setAttribute("data-job-id", jobId);
            itemEl.innerHTML = `
              <div class="job-status-indicator ${state}"></div>
              <div class="job-info">
                <div class="job-command"></div>
                <div class="job-detail"></div>
              </div>
              <div class="job-actions">
                <span class="job-link-icon">‚Üí</span>
                <button onclick="event.preventDefault(); event.stopPropagation(); cancelJobById('${jobId}')">Cancel</button>
              </div>
            `;
            listEl.appendChild(itemEl);
          }

          itemEl.className = "job-item " + state;
          itemEl.querySelector(".job-status-indicator").className =
            "job-status-indicator " + state;
          itemEl.querySelector(".job-command").textContent =
            command + (args ? " " + args : "");
          itemEl.querySelector(".job-detail").textContent = input || "No input";
        });

        listEl.querySelectorAll(".job-item").forEach((el) => {
          const jobId = el.getAttribute("data-job-id");
          if (!existingIds.has(jobId)) {
            el.remove();
          }
        });
      }

      function cancelJobById(id) {
        fetch(`/job/${id}/cancel`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        })
          .then((r) => r.text())
          .then((result) => console.log("Cancelled:", result))
          .catch((err) => console.error("Error:", err));
      }

      // SSE Connection Management
      document.addEventListener("DOMContentLoaded", function () {
        const STREAM_URL = "/stream";
        const connectionStatusEl = document.getElementById("connectionStatus");

        const sseState = {
          es: null,
          reconnectTimer: null,
          heartbeatTimer: null,
          connectingTimer: null,
          backoffMs: 1000,
          maxBackoffMs: 30000,
          isConnecting: false,
          isExplicitlyClosed: false,
          lastActivityTs: Date.now(),
          lifecycleSetup: false,
        };

        function updateConnectionStatus(status) {
          connectionStatusEl.className = "connection-status " + status;
          const textEl = connectionStatusEl.querySelector("span:last-child");
          if (status === "connected") {
            textEl.textContent = "Connected";
          } else if (status === "connecting") {
            textEl.textContent = "Connecting...";
          } else {
            textEl.textContent = "Disconnected";
          }
        }

        function withJitter(ms) {
          const jitter = Math.floor(ms * 0.2 * Math.random());
          return ms + jitter;
        }
        function resetBackoff() {
          sseState.backoffMs = 1000;
        }
        function onActivity() {
          sseState.lastActivityTs = Date.now();
          resetBackoff();
        }
        function stopHeartbeat() {
          if (sseState.heartbeatTimer) {
            clearInterval(sseState.heartbeatTimer);
            sseState.heartbeatTimer = null;
          }
        }
        function startHeartbeat() {
          stopHeartbeat();
          sseState.heartbeatTimer = setInterval(() => {
            const inactiveMs = Date.now() - sseState.lastActivityTs;
            if (inactiveMs > 45000) {
              console.warn("SSE idle too long; recreating connection");
              recreateConnection();
            }
          }, 15000);
        }
        function clearConnectingTimer() {
          if (sseState.connectingTimer) {
            clearTimeout(sseState.connectingTimer);
            sseState.connectingTimer = null;
          }
        }
        function scheduleReconnect(reason) {
          if (sseState.isExplicitlyClosed) return;
          if (sseState.reconnectTimer) return;
          const delay = withJitter(sseState.backoffMs);
          console.log(`SSE reconnect in ${delay}ms (${reason || ""})`);
          updateConnectionStatus("disconnected");
          sseState.reconnectTimer = setTimeout(() => {
            sseState.reconnectTimer = null;
            connect();
          }, delay);
          sseState.backoffMs = Math.min(
            sseState.maxBackoffMs,
            sseState.backoffMs * 2
          );
        }
        function cleanupES(markExplicit) {
          if (markExplicit) sseState.isExplicitlyClosed = true;
          stopHeartbeat();
          clearConnectingTimer();
          if (sseState.es) {
            try {
              sseState.es.close();
            } catch (e) {}
          }
          sseState.es = null;
          sseState.isConnecting = false;
        }
        function recreateConnection() {
          cleanupES(false);
          connect();
        }

        function parseJobFromEvent(data) {
          try {
            const parsed = JSON.parse(data);
            return parsed.job || parsed;
          } catch (e) {
            return null;
          }
        }

        function connect() {
          if (sseState.isConnecting) return;
          if (sseState.es && sseState.es.readyState !== EventSource.CLOSED)
            return;
          if (!navigator.onLine) {
            scheduleReconnect("offline");
            return;
          }
          if (document.visibilityState === "hidden") {
            scheduleReconnect("hidden");
            return;
          }
          sseState.isConnecting = true;
          updateConnectionStatus("connecting");

          try {
            console.log("Connecting to EventSource...");
            const es = new EventSource(STREAM_URL);
            sseState.es = es;
            clearConnectingTimer();
            sseState.connectingTimer = setTimeout(() => {
              if (
                sseState.es &&
                sseState.es.readyState === EventSource.CONNECTING
              ) {
                console.warn("SSE stuck CONNECTING; recreating");
                recreateConnection();
              }
            }, 20000);

            es.onopen = () => {
              sseState.isConnecting = false;
              clearConnectingTimer();
              onActivity();
              startHeartbeat();
              updateConnectionStatus("connected");
              console.log("EventSource connected.");
              fetchInitialJobs();
            };

            es.onerror = (error) => {
              console.warn("SSE error", error);
              onActivity();
              if (!sseState.es) return;
              if (sseState.es.readyState === EventSource.CLOSED) {
                cleanupES(false);
                scheduleReconnect("closed");
              } else if (sseState.es.readyState === EventSource.CONNECTING) {
                scheduleReconnect("connecting");
              }
            };

            es.addEventListener("create", (event) => {
              onActivity();
              const job = parseJobFromEvent(event.data);
              if (job && (job.id || job.ID)) {
                jobsState.jobs.set(job.id || job.ID, job);
                renderActiveJobsList();
                updateCardStatuses();
              }
            });

            es.addEventListener("update", (event) => {
              onActivity();
              const job = parseJobFromEvent(event.data);
              if (job && (job.id || job.ID)) {
                jobsState.jobs.set(job.id || job.ID, job);
                renderActiveJobsList();
                updateCardStatuses();
              }
            });

            es.addEventListener("delete", (event) => {
              onActivity();
              const data = JSON.parse(event.data);
              const jobId = data.job?.id || data.job?.ID;
              if (jobId) {
                jobsState.jobs.delete(jobId);
                renderActiveJobsList();
                updateCardStatuses();
              }
            });
          } catch (e) {
            console.error("SSE connect threw", e);
            sseState.isConnecting = false;
            scheduleReconnect("exception");
          }
        }

        function fetchInitialJobs() {
          fetch("/jobs/list")
            .then((r) => r.json())
            .then((jobs) => {
              jobsState.jobs.clear();
              if (Array.isArray(jobs)) {
                jobs.forEach((job) => {
                  if (job.id || job.ID) {
                    jobsState.jobs.set(job.id || job.ID, job);
                  }
                });
              }
              renderActiveJobsList();
              updateCardStatuses();
            })
            .catch((err) => {
              console.warn("Failed to fetch initial jobs:", err);
            });
        }

        function setupLifecycle() {
          if (sseState.lifecycleSetup) return;
          sseState.lifecycleSetup = true;
          window.addEventListener("online", () => {
            resetBackoff();
            connect();
          });
          window.addEventListener("offline", () => {
            cleanupES(false);
            updateConnectionStatus("disconnected");
          });
          document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === "visible") {
              resetBackoff();
              connect();
            }
          });
          window.addEventListener("focus", () => {
            resetBackoff();
            if (!sseState.es || sseState.es.readyState === EventSource.CLOSED) {
              connect();
            } else {
              const inactiveMs = Date.now() - sseState.lastActivityTs;
              if (inactiveMs > 15000) {
                recreateConnection();
              }
            }
          });
          window.addEventListener("pageshow", () => {
            resetBackoff();
            connect();
          });
          window.addEventListener("pagehide", () => {
            cleanupES(false);
          });
          window.addEventListener("beforeunload", () => {
            cleanupES(true);
          });
        }

        setupLifecycle();
        connect();
      });

      // Populate directory suggestions
      (function loadPathDirSuggestions() {
        fetch("/media/suggest?kind=pathdir&limit=50")
          .then((r) => r.json())
          .then((data) => {
            const list = document.getElementById("pathdir-suggestions");
            if (!list || !Array.isArray(data.suggestions)) return;
            list.innerHTML = "";
            data.suggestions.forEach((p) => {
              const opt = document.createElement("option");
              opt.value = p;
              list.appendChild(opt);
            });
          })
          .catch(() => {});
      })();
    </script>
  </body>
</html>
{{ end }}
